# Vue 核心知识

### 响应式

* `ref()`

* `reactive()`

* `computed()`

* `watchEffect()`

* `watch()`

* `shallowRef()`

* `shallowReactive()`



### 响应式原理

* 低侵入性响应式系统，组件状态是由响应式的JavaScript对象组成。

* 什么是响应式？

  * 响应式是可以声明式地处理变化的编程范式

  * 需要监听变量的属性读写，根据是否变化来作出反应，比如更新视图，或者进一步处理事件。

* Vue中实现响应式

  * 追踪读写变化

    * 两种劫持方式：`getter/setters`、`Proxies`

      * `getter/setters`用于 ref的基础数据类型

      * 引用类型，ref将借助reactive重新包装

* 响应式副作用

  * Vue创建了一个能自动追踪依赖的副作用

  * 它会在任意依赖改动时重新运行

  * 可以使用`watch`、`computed`便是利用了这一点。

* `ref`和`reactive`的区别？

  * `ref`是通过中间对象劫持，接收要劫持的值时，会转换成中间对象，所以数据类型支持基本数据类型和对象，通过`.value`访问值

    * `watch`默认值观察`value`这一层，不会进行深度监听

    * `ref`会使用`reactive`管理对象类型

  * `reactive`通过Proxy进行劫持，不支持基本数据类型

    * 解构赋值后，会断开和原来对象的链接，两者值会不同步

### 渲染机制

* 虚拟DOM

  * 概念：将UI或者HTML元素，通过数据结构虚拟地表示出来，然后将真实DMO和虚拟DOM保持一致。

  * 编译：Vue模版被编译为渲染函数，构建出虚拟DOM。

  * 挂载：虚拟DOM被构建为真实的DOM，这个过程称为挂载

  * 更新：响应式发生变化时，两份DOM树，保持同步更新的过程叫做更新

  * 协调/对比：更新的过程需要对比，又要根据线程忙不忙条度更新时间，以便提高渲染性能。

* Vue渲染设计

  * 带编译时信息的虚拟DOM

    * 编译器可以静态分析模版并在生成代码中留下标记，使得运行时尽可能地走捷径。

  * 静态提升

    * 不带任何动态绑定

    * 完全跳过差异对比

  * 更新类型标记

    * 具有指令绑定，样式或者属性绑定的元素

    * 会被放在一个打平的数组中，以方便遍历，里面不包含静态节点
