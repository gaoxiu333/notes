# TypeScript 基础类型

- 完备工整的 [cheatsheet](https://www.sitepen.com/blog/typescript-cheat-sheet)

## 类型

### **基本类型**

`boolean`, `string`, `number`

`undefined`, `null`

`bigint`, `symbol`

`any`, `unknown` , `never`, `void`

### **特殊类型**

`tuple` , `enum` 

### 引用类型

- **对象**：{ field: string }
- **函数**：(arg: number) => string
- **数组**：string[] 或 Array<string>
- **元组 (Tuple)**：[string, number]

**内置对象**

`Date`, `Error`, `Array`, `Map`,`Set`, `Regexp`, `Promise` 等

### 类型运算符

**常用运算符**

类型系统的核心，用于定义或组合基本类型

- 联合类型： `string | number`
- 交叉类型： `type A = { x:number} & {y:number}`
- `keyof` :  `type B = keyof { a: 1; b: 2 }` ⇒  `a | b`
- `typeof` : `type T = typeof someVariable` ⇒ 推导 `someVariable` 的类型

**条件运算符**

提供了类型的动态推导机制

- `extends` ： `type T = A extends B ? C : D`
- `infer` : 条件类型中用于推导某一部分类型

**类型映射**

用来方便的创建复杂的类型结构

- `in` : 遍历类型的键
- 索引访问： `type T = User['name']`
- 映射类型： `type Readonly<T> = { [K in keyof T]: T[k]}`

**工具类型**

- `Partial<T>`
- `Required<T>`
- `Readonly<T>`

**字面量类型 (Literal Types)**

字面量类型是指使用具体的值（如字符串、数字或布尔值）作为类型，从而限制变量或返回值只能取这些特定值之一。

## Interface VS type

- `interface` 用于定义对象、类接口，支持继承和声明合并，适合定义面向对象风格的类型
- `type` 用于定义任意类型（包括联合、交叉），更灵活，适合定义复杂类型。
    
    
    | 特性 | iterface | type |
    | --- | --- | --- |
    | 定义对象类型 | ✅  支持 | ✅ 支持 |
    | 联合/交叉类型 | ❌ 不支持 | ✅ 支持 |
    | 继承/拓展 | ✅ 支持 | ✅ 支持 |
    | 声明合并 | ✅ 支持 | ❌ 不支持 |

## Interface

用于描述对象的结构，可以被其他接口扩展。

**关键语法示例：**

```tsx
interface JSONResponse extends Response {
  version: number;
  payloadSize: number;
  outOfStock?: boolean;
  update(retryTimes: number): void;
  (): JSONResponse;
  (s: string): JSONResponse;
  [key: string]: number;
  readonly body: string; // 属性为只读
}
```

**特点：**

- **继承 (extends)**：通过 extends 继承其他接口。
- **可选属性 (**?**)**：定义可能不存在的属性。
- **函数属性**：可以定义为函数。
- **索引签名 (**[key: string]: number**)**：允许未定义的属性，其值需符合类型。
- **只读属性 (**readonly**)**：属性不能被修改。

### 接口拓展

- 接口合并
- 继承？

### 其他

- 重载，它是函数的吗
- 泛型
- interface 如何定义函数

## Type

全名为 `type alias` 用于定义灵活的类型结构，支持更丰富的类型系统。

**关键语法示例**

```tsx
type JSONResponse = {
  version: number; // 字段
  payloadSize: number; // 字段
  outOfStock?: boolean; // 可选字段
  update: (retryTimes: number) => void; // 箭头函数字段
  (retryTimes: number): void; // 可调用类型
  (): JSONResponse; // 返回类型为 JSONResponse
  [key: string]: number; // 任意索引
  new (s: string): JSONResponse; // 构造函数
  readonly body: string; // 只读属性
};
```

**特点**

- **交叉类型 (&)**：合并多个类型。
- **联合类型 (|)**：定义多个可选值。
- **条件类型 (extends ? : )**：根据条件动态生成类型。
- **映射类型 ([key in keyof T])**：动态生成键值对类型。
- **模板字符串类型 (**${}**)**：构建动态字符串类型。

```tsx

// 从值派生类型
const data = { x: 10, y: 20 };
type Date = typeof data;

// 从函数返回值派生类型
function createFixtures(){
    return {id:1,name:"example"}
}
type Fixtures = ReturnType<typeof createFixtures>

// 模版字符串类型
type Local = `${'en' | 'pt' | 'zh'}_${'header' | 'footer'}`
// 'en_header' | 'pt_header' | 'zh_header' | 'en_footer' | 'pt_footer' | 'zh_footer'

// 映射类型
type Subscriber<T> = {
    [K in keyof T]: (value:T[K]) => void
}

// 条件类型
type HasFourLegs<T> = T extends { legs: 4} ? T : never;
```

## Class

```tsx
class UserAccount {
  readonly id: string;      // 只读字段，初始化后不可修改
  name?: string;            // 可选字段，可能不存在
  #userCount = 0;           // 私有字段 (运行时私有)
  
  constructor(public email: string, id: string) { // 参数属性初始化字段
    this.id = id; 
  }

  get displayName(): string {  // Getter 方法
    return this.name ?? "Anonymous";
  }

  set displayName(value: string) {  // Setter 方法
    this.name = value;
  }

  static maxUsers = 100;          // 静态字段，属于类本身
  static isAllowed(): boolean {   // 静态方法
    return UserAccount.maxUsers > 0;
  }

  private logAction(action: string): void { // 编译期私有方法
    console.log(`Action: ${action}`);
  }
}
```

### 特点

- **构造函数**：constructor 可直接初始化字段。
- **参数属性 (**public**,** private**,** protected**)**：构造函数参数可直接声明为实例字段。
- **访问修饰符**：
    - public (默认)：字段或方法对外公开。
    - private：编译期私有，仅类内访问，运行时不限制。
    - #private：运行时私有字段，受 JavaScript 引擎严格限制。
    - protected：在类及子类内可访问。
- **只读属性 (**readonly**)**：声明后不可修改，但必须初始化。
- **可选字段 (**?**)**：声明字段可能不存在。
- **Getter/Setter**：使用 get 和 set 定义访问器，类似属性访问。
- **静态字段与方法 (**static**)**：直接绑定到类本身，而非类实例。
- **抽象类 (**abstract**)**：
    - 抽象类不能实例化，只能被继承。
    - 抽象方法必须在子类中实现。
- **类型与值双重身份**：类既可作为值 (实例化)，也可作为类型使用。

### 补充

 **抽象类与继承**

```tsx
abstract class Animal {
  abstract makeSound(): void; // 抽象方法，必须在子类中实现

  move(): void {
    console.log("Moving...");
  }
}

class Dog extends Animal {
  makeSound(): void {
    console.log("Bark!");
  }
}
```

**装饰器（实验特性）**

```tsx
function ReadOnly(target: any, key: string) {
  Object.defineProperty(target, key, {
    writable: false,
  });
}

class Example {
  @ReadOnly
  readonly name = "Cannot Change";
}
```

### 范型（Generice）

- **范型**允许我们定义函数、类或接口时使用参数化的类型，而不是固定的类型。
- **范型约束：**通过 **extends** 关键字范型约束用于限制范型的类型范围

```tsx
interface APICall<Response extends { status: number }> {
  data: Response;
}
// extends 约束了类型，必须要要有 status
const api: APICall<{ status: number }> = {
  data: {
    status: 200,
  },
};

api.data.status;
```

## CFA 控制流分析

**概念**

**控制流分析**（CFA）主要处理联合类型，通过代码逻辑减少联合类型中的可能类型。

通过代码逻辑（如 if 表达式、函数返回值或抛出异常）动态减少联合类型的可能性，让类型更精准，并支持自定义类型守卫以进一步影响类型收窄。

**关键语法示例**

```tsx
const input = getUserInput();

if (typeof input === "string") {
    input; // 收窄为 string
} else if (input instanceof Array) {
    input; // 收窄为 number[]
} else if ("error" in input) {
    input; // 收窄为 { error: ... }
}
```

**特点**

- **基础类型守卫**：typeof 用于基本类型，instanceof 用于类，in 用于对象属性。
- **自定义类型守卫**：通过函数定义守卫，返回布尔值或使用断言（asserts）改变作用域。
- **判别联合类型**：基于共享属性（如 status）区分联合类型成员。
- **表达式收窄**：布尔操作符可动态调整变量类型。
- **字面量锁定**：as const 固定字面量类型，避免类型“宽化”。

**三元运算**

条件判断，特点是，只需要考虑**兼容**性，而不是全等

`type LiteralType<T> = T extends string ? "string" : "other";`

## 参考：

- https://rmolinamir.github.io/typescript-cheatsheet/

https://www.sitepen.com/blog/typescript-cheat-sheet

这个不错哦！！