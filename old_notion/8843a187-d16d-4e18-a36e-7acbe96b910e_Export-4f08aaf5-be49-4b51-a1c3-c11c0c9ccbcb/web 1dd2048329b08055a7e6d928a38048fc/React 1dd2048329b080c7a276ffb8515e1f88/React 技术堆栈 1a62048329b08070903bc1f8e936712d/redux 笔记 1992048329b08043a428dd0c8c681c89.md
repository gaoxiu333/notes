# redux 笔记

## 学习计划

首先了解基本的概念和术语

**一个简单的示例，了解核心 API**

## 浏览器工具

- React DevTools 扩展：
    - [Chrome 的 React DevTools 扩展程序](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en)
    - [适用于 Firefox 的 React DevTools 扩展](https://addons.mozilla.org/en-US/firefox/addon/react-devtools/)
- Redux DevTools 扩展：
    - [Chrome 版 Redux DevTools 扩展程序](https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd?hl=en)
    - [适用于 Firefox 的 Redux DevTools 扩展](https://addons.mozilla.org/en-US/firefox/addon/reduxdevtools/)

熟悉术语/编程范式

## action 操作对象

```bash
action: 操作对象
{
	type:"domain/eventName" // 是一个标识，也可以描述操作对象要做的事情
	payload:some data // 一些额外数据，约定俗成的做法
}

通常我们会通过 action 创建函数来创建一个操作对象

const addTodoAction = (text)=>{
	return {
		type:'todos/todoAdded',
		payload:text
	}
}
```

## reducer 事件监听器

接受当前对象和操作，决定合适以及如何更新状态，并返回最新的状态

- 接受 `state` 和 `action` 的函数
- 内部使用了大量 `if/else` 或者 `switch`

## redux toolkit

```bash
定义
configureStore 定义并返回一个 store
改变
通过store.dispatch(action()) 改变
读取
通过store.getState() 读取
```

## 单向数据流

- state 决定ui渲染的数据
- ui 通过触发事件，执行 action
- action 修改 state
- state 改变ui渲染的数据
- em 大家朝着一个方向使劲发展。

## 什么是切片

切片是应用中单个功能 Redux Reducer 逻辑和操作的集合，定义来源

```bash

export const store = configureStore({
  reducer: {
    users: usersReducer, // Redux 状态单独切片 users，它只负责 users
    posts: postsReducer, // Redux 状态单独切片 posts，只负责 posts
    comments: commentsReducer
  }
})
```

1. 切片创建
    1. **`createSlice`**

```bash
export const counterSlice = **createSlice**({
  name: 'counter',
  initialState,
  reducers: {
    increment: state => {
      state.value += 1
    },
    decrement: state => {
      state.value -= 1
    },
    incrementByAmount: (state, action: PayloadAction<number>) => {
      state.value += action.payload
    }
  }
})
export const { increment, decrement, incrementByAmount } = counterSlice.actions
export default counterSlice.reducer
```

todo吧，写一个小炒，这里先定义一下术语以及常见的 redux-toolkit api

- 创建切片
- `store.getState()`
- `thunks` 编写异步逻辑。
- 预先定义的 读取和操作封装
    - `useSelector` 读取数据
    - `useDispatch` 封装action函数

toolkit 中涉及到的第三方插件/工具

- immer
- 
- react-redux  不确定

## 正式开始

### redux-toolkit

- configureStore
    - 始终需要一个 `reducer` 或者是一个 slice reducers
    - `slice` 概念
        - 单个功能的Redux reducer 逻辑的集合。
        - `createSlice` 创建 slice reducer 的核心函数

### React-Redux

- `<Provider>` 当然，首先要提供了

## Chunk 异步

- `createAsyncThunk`
    - 将 `pending` , `fulfilled` , `failed`  三个一了，不用自己在写 loading处理，错误捕获了。
    - ts 定义类型提示：[Type Checking Redux Thunks](https://redux.js.org/usage/usage-with-typescript#type-checking-redux-thunks)
- `extraReducers` 在reducer中添加 action，用来给异步事件调用

## 再来一个中间件

- 专门用来存放 redux 中需要的 effect 操作
- chunk 也是中间件，但它是功能
- 另一个是监听器
    - `createListenerMiddleware`
    - 它与 `useEffect` 很相似，但它不属于react，它是 redux 生命周期内的，遵循redux生命周期。

## 性能优化

- 时间穿梭
- `createSelector` 可以创建类似 `useMemo` 的缓存，被称为 memoized selectors
- `createEntityAdapter` ??
- 使用 `createSelector` 和 `React.memo` 优化组件
- 使用 `createEntityAdapter` 优化数组

## 额外的

- 在 `immer` 中 `array.sort` 可以直接排序 `array`,emmm 很不错
- 归一化：用来快速查找 `array.find` 的替代
    - 额。。。 好吧，听着这么高大上
    - 竟然只是将 array 转换为 object，然后通过对象的属性访问。
    - 原来如此，那么就需要存一份 对象备份。
    - api： `createEntityAdapter`
        - 它操作一组 `ids` 和 `entities`
    - 使用 **`createListenerMiddleware` 用于监听Redux数据变化，犹如 useEffect 一样**

## RTK

- 一个代替手写数据获取的附加组件
- 它包含在 Redux Toolkit 内

它解决了一些样板代码的重复使用问题

- 跟踪请求的加载状态
- 避免重复请求
- 乐观更新
- 缓存管理（过期等）
- **`transformResponse` 转换响应数据格式**

整体和 react-query差不多