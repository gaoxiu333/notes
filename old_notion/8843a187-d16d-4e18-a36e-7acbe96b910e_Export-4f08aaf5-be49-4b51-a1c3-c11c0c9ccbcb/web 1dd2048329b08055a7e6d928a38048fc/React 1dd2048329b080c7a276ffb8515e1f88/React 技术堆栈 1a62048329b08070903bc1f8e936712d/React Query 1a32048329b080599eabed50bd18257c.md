# React Query

## 核心机制原理

### **1. Query Key 设计原则**

- 数组结构，层级化组织（类似 URL 路径）
    
    `['users', { page: 1 }, 'details']`
    
- **相同 Key 复用缓存**，不同 Key 创建新查询
- 动态部分放后面：`['config', region]`

### **2. 数据生命周期（再细化一下）**

```bash
fresh → stale → inactive → garbage collected
  │        │         │
  │        │         └─ 无观察者时进入休眠
  │        └─ 触发后台重新验证 (staleTime 默认 0)
  └─ 直接使用缓存 (staleTime > 0 时)
```

### **3. 请求竞态处理**

- 自动取消重复请求 (默认行为)
- 最后一次请求结果覆盖之前结果

## 初始化

- [eslint](https://tanstack.com/query/v5/docs/eslint/eslint-plugin-query)
- [devtools](https://tanstack.com/query/v5/docs/framework/react/devtools)

```bash
pnpm add @tanstack/react-query
pnpm add -D @tanstack/react-query-devtools @tanstack/eslint-plugin-query
```

### **配置架构图**

```jsx
QueryClient
├── Default Options  # 全局默认设置
│   ├── queries      # 所有查询的默认行为
│   └── mutations    # 所有变更的默认行为
├── QueryCache       # 缓存存储引擎
├── MutationCache    # 变更操作存储
└── Logger           # 调试日志系统
```

### **配置原理速记表**

**核心选项（options）**

| **字段** | **类型** | **描述** |
| --- | --- | --- |
| **enabled** | `boolean` | 是否启用自动查询（默认 `true`）。设为 `false` 时需手动触发 `refetch`。 |
| **staleTime** | `number` | 数据保鲜时间（毫秒），避免重复请求 |
| **gcTime** | `number` | GC垃圾回收，失活后多久被回收 |
| **refetchOnWindowFocus** | **`boolean`** | 切浏览器 tab 是否刷新，默认 ture，但通常不需要 |
| **networkMode** | `'online' | 'always' | 'offlineFirst'` | 控制网络行为（如离线处理）。 |

更详细的配置：[useQuery](https://tanstack.com/query/v5/docs/framework/react/reference/useQuery)

**配置记忆锚点**

1. **缓存双周期**：`staleTime` (逻辑周期) 和 `gcTime` (物理周期) 解耦设计
2. **错误处理链**：局部 onError > 全局 onError > 错误边界 (Error Boundary)
3. **分层生效**：useQuery选项 > 全局 defaults > 框架默认值
4. **缓存键隔离**：不同 QueryClient 实例完全隔离缓存

### **全局默认配置示例 (`defaultOptions`)**

```jsx
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 60 * 1000,    // 数据保鲜期（默认0即立即过期）
      gcTime: 5 * 60 * 1000,   // 缓存保留时间（默认5分钟）
      retry: 3,                // 错误重试次数策略
      refetchOnWindowFocus: false, // 窗口聚焦时刷新
      networkMode: 'online'     // 离线模式处理策略
    },
    mutations: {
      retry: 0                 // 变更默认不重试
    }
  }
})
```

**原理要点**：

- `staleTime > 0` 会延迟后台刷新触发
- `gcTime` 影响内存占用和恢复能力
- `networkMode` 控制离线时的请求队列行为

**缓存引擎配置 (`QueryCache`)**

```jsx
const queryClient = new QueryClient({
  queryCache: new QueryCache({
    onError: (err) => {},          // 全局错误捕获
    onSuccess: (data) => {},       // 全局成功回调
    onSettled: (data, err) => {}   // 全局完成回调
  })
})
```

**机制说明**：

- 每个 QueryClient 独立维护缓存实例
- 可创建多个 QueryClient 实现沙箱隔离

### **开发工具集成**

```jsx
// 开发环境下启用调试工具
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'

function App() {
  return (
    <>
      <QueryClientProvider client={queryClient}>
        {/* 应用组件 */}
      </QueryClientProvider>
      <ReactQueryDevtools 
        initialIsOpen={false} 
        position="bottom-right" 
        toggleButtonProps={{ style: { right: '5px' } }} 
      />
    </>
  )
}
```

**调试原理**：

- 实时显示缓存状态树
- 手动触发缓存失效/刷新
- 可视化观察者依赖关系

其他配置：

- 服务端渲染（SSR）配置
- 离线优先策略
- 性能优化配置

## 核心 API 原理速记

### useQuery

参考：[useQuery](https://tanstack.com/query/v5/docs/framework/react/reference/useQuery)

```jsx
const { 
	 data,
	 status,
	 refetch,           // 手动刷新
	 error,
	 isPending,         // 是否处于首次加载状态（无缓存数据时）。
	 isFetching,        // 是否正在请求中（包括后台刷新）。

 } = useQuery({
  queryKey: ['todos'],       // 缓存定位标识
  queryFn: fetchTodos,       // 实际数据获取函数
  staleTime: 10_000,         // 新鲜→过期状态切换时间
  gcTime: 30_000,            // 内存保留时间
  retry: 3                   // 错误重试策略
})
```

### **高级功能**

- **依赖查询**：通过 `enabled: false` 和手动调用 `refetch` 实现依赖其他查询的触发逻辑。
- **分页查询**：结合 `keepPreviousData: true` 保留旧数据，提升分页体验。
- **预加载**：使用 `queryClient.prefetchQuery` 提前加载数据到缓存

### **useMutation**

```jsx
const mutation = useMutation({
  mutationFn: postData,
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: ['items'] }) // 失效旧缓存
  },
  retry: false // 突变默认不重试
})
```

## 特性

### 预加载模式

```jsx
// 提前将数据放入缓存
await queryClient.prefetchQuery({
  queryKey: ['user', userId],
  queryFn: () => fetchUser(userId)
})
```

### 手动缓存

```jsx
/ 直接写入缓存
queryClient.setQueryData(['todo', id], newTodo)

// 获取缓存快照
const cached = queryClient.getQueryData(['todo', id])

// 批量失效缓存
queryClient.invalidateQueries({ queryKey: ['todos'] })
```

### 错误处理

```jsx
// 全局错误处理
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      onError: (err) => handleGlobalError(err)
    }
  }
})

// 本地错误处理
useQuery({
  queryKey: ['data'],
  queryFn: fetchData,
  onError: (err) => handleLocalError(err)
})
```

---

<aside>
💡

## **原理向速记技巧**

1. **缓存目录**：把 `queryKey` 想象成文件路径
    
    `['users', 'list', { page: 2 }]` → `/users/list?page=2`
    
2. **状态流转**：画时间轴理解 fresh/stale/inactive
3. **依赖关系**：组件卸载 = 观察者取消订阅 ≠ 缓存删除
4. **性能关键**：`staleTime` 和 `gcTime` 的平衡艺术
</aside>

## TODO

### TypeScript 支持

https://tanstack.com/query/v5/docs/framework/react/typescript

### 插件

- `@tanstack/react-query-persist-client` 持久化缓存（storage）
- 还有 eslint

### QueryClient

- 经常使用的方法有哪些

### Options

- **staleTime**
- gcTime
- **initialData**
- **refetchOnWindowFocus 浏览器后台切前台后刷新数据**
- placeholderData VS initialData
- **select**
- **suspense 需要 Error Boundary**

返回

- isPending VS isFetching
- **refetch**

### **高级功能**

- **依赖查询**：通过 `enabled: false` 和手动调用 `refetch` 实现依赖其他查询的触发逻辑。
- **分页查询**：结合 `keepPreviousData: true` 保留旧数据，提升分页体验。
- **预加载**：使用 `queryClient.prefetchQuery` 提前加载数据到缓存。

### **注意事项**

1. **缓存策略**：`staleTime` 和 `gcTime` 控制数据的保鲜和垃圾回收。
2. **TypeScript**：可通过泛型指定数据类型（如 `useQuery<TData, TError>`）。
3. **性能优化**：合理使用 `select` 和 `structuralSharing` 避免不必要的渲染