# React 的重新渲染

## 参考

- [重新渲染相关的面试题](https://bigfrontend.dev/react-quiz)
- [React hooks 执行顺序](https://julesblom.com/writing/react-hook-component-timeline)
- [Why React Re-Renders](https://www.joshwcomeau.com/react/why-react-re-renders/)
- [react 渲染行为指南](https://blog.isquaredsoftware.com/2020/05/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior/#standard-render-behavior)

### 为什么 React 需要重新渲染？

1. **核心目标：确保 UI 与状态同步**
    
    React 的核心设计是 **状态驱动UI**，通过重新渲染机制保证应用状态的变化始终反应在界面上，避免手动操作 DOM 的繁琐和出错。
    
    - **目标：**任何状态的变化都反应在界面上。
    - **实现方式：**通过重新渲染更新虚拟DOM，然后通过 dif 算法最小化对真实 DOM 的操作
    - **例子：**一个计数器按钮点击时更新数字，React 需要重新渲染来显示新的计数值。
2. **状态变化引起的动态更新**
    
    当组件的 state 和 props 发生变化时，React 会触发重新渲染，将这些变化映射到用户界面，确保应用实时响应用户交互或后台数据更新。
    
3. **高效更新：虚拟 DOM 的 diff 算法**
    - **核心原理**：状态变化后，React 会重新渲染对应组件，生成新的虚拟 DOM 树，然后与之前的虚拟 DOM 进行 diff 比较，仅更新必要的部分。
    - **优势**：即使 React 频繁重新渲染组件，实际的 DOM 操作仍然是最小化的，性能得到了保障。

**总结**

React 需要重新渲染的原因可以归结为以下几点：

1. 保证 UI 和状态一致。
2. 提高开发效率，简化状态管理。
3. 提供对动态和交互式界面的支持。
4. 借助虚拟 DOM 高效处理更新，避免性能问题。

## 什么会触发重新渲染

1. 组件状态 `state` 的变化
2. 组件属性 `props` 的变化
3. 上下文或父组件的影响
4. 手动强制更新 `flushSync`

## 渲染优化

要优化渲染性能，主要是灵活运用 `React.memo` 、 `useCallback` 、 `useMemo` 以减少不必要的重新渲染。

1. 组件自身的 state 发生变化
    - 原因：当组件的 state 更新时，React 必须重新渲染以确保 UI 和 state 保持同步
    - 注意：即使 state 的值与旧值相同（但可能引用不同）所以也会触发重新渲染，但是react会优化组件的实际更新。
2. 组件的 props 发生变化
    - 原因：和state一样
    - 优化：通过 React.memo 来避免不必要的重新渲染
3. 父组件的重新渲染
    - 原因：无论当前组件的重新渲染，都会导致所有子组件的重新渲染（递归）
    - 优化：使用 React.memo 包装子组件，它会阻止父组件的重新渲染，只有子组件的 props 变化时才会引起子组件重新渲染，又因为是浅比较，使用 useCallback 和 useMemo 缓存子组件的 props
4. 上下文 Context 的变化
    
    原因：useContext 会订阅上下文的值变化，任何变更都会触发相关组件重新渲染。
    
    优化：通过拆分上下文将上下文的颗粒度控制到较小的范围。
    
5. 组件 `key` 属性变化
    
    React 使用 key 属性来唯一标识组件实例，key的变化会导致组件被卸载并重新挂载，从而触发重新渲染。
    

### 文章总结

1. React 重新渲染都是 state 改变引起的，他是唯一触发器
2. 也不对，props也可以，上下文也可以
3. 组件重新渲染会引起所有子组件重新渲染
4. 每次渲染都是一个快照，然后比较新旧两个快照？

React 这么做时为了保持应用程序 UI 与 React 状态保持同步，重新渲染的目的是为了找出需要更改的内容

**其他优化**

**Fiber 和 key**

- 根据 `type` （元素类型）来决定是否创建 DOM 元素
- 根据 `key` 来决定是否复用，删除原来的 DOM 重新创建

**如何理解使用 React.memo，什么时候使用 useCallback**

- `React.memo` 告诉 React 这个组件是纯组件（props没有发生改变就就不需要重新渲染了）
    - react 为什么不默认提供 React.memo 包装所有组件
    - 因为大部分情况下，重新渲染的速度很快，React.memo 需要比较props是否发生改变，才能确定是否需要重新渲染，它是有比较算法的。

## 减少重新渲染的次数

- **`useMemo`本质上就像一个小缓存，依赖项是缓存失效策略。**
- 当使用 React.memo 包裹子组件时，props 是一个引用对象时，使用 useMemo 包裹
- 如果是函数呢，那就需要 useCallback

**更多选择**

在他的博客文章[“在你备忘录之前（）”中 （在新标签页中打开）](https://overreacted.io/before-you-memo/)，

## 那么渲染过程是什么呢？