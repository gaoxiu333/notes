# React Memoization

执行资源密集型函数时，最大限度地减少内存和事件的使用。工作原理是：存储函数的最后计算值或者对象，当使用相同的参数重复调用函数时，可以让我们绕过函数的昂贵计算

- `useMemo` - 缓存函数的值，当函数的传递的参数于前一次相同时，返回上一次计算的值，参数更新时，重新计算返回新值
    - 记忆的是值，而不是函数，区别于 `useCallback`
- `useCallback` - 缓存函数
- `React.momo` - 缓存组件，仅当 props 和内部状态发生更改时才会重新渲染

## React.momo

- 默认对传入的 props 进行浅比较，如果相等则不会发生重新渲染

**自定义比较**

- 第二个参数可以传入可以自定义比较函数

```jsx
React.memo(Com,customComparator)
```

## useCallback

**为什么使用？** 

组件每次重新渲染时会创建新的单独函数对象，破坏了传递到子组件并在子组件内部调用的回调的引用相等性

- 确保回调函数引用相等
- 如果需要在 useEffct或者传递给子组件时，需要对函数进行对比时，使用 useCallback