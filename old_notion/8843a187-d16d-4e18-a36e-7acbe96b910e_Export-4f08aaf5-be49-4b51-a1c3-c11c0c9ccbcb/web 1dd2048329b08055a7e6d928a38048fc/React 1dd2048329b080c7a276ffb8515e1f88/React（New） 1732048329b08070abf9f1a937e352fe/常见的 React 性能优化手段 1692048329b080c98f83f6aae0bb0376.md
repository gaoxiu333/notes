# 常见的 React 性能优化手段

## 草稿

- `useTransition`
- `useDeferredValue`
    - 避免它阻塞 UI 的渲染
- React Hooks 闭包陷阱
- 让 useEffect 支持 async/await，主要是看下 ahook 是怎么实现的

React 性能优化

- 减少计算量
    - 掘金文章 → gpt 总结
- 利用缓存
    - 同上

## 渲染

React 父组件更新会导致所有子组件更新，但是可以通过 React.memo包装子组件

- react渲染行为指南 https://medium.com/@sparshmalhotraaa/a-guide-to-react-rendering-behaviour-part-2-28c3dc93ca3a

Q: Is it safe to perform side-effects in a ref callback?问：在 ref 回调中执行副作用安全吗？

Toggle answer  切换答案

Yes, because a ref callback is **not** part of the render phase [2](https://julesblom.com/writing/react-hook-component-timeline#user-content-fn-refupdateordering).是的，因为 ref 回调**不是**渲染阶段的一部分 [2](https://julesblom.com/writing/react-hook-component-timeline#user-content-fn-refupdateordering) .

(See [Render and Commit](https://react.dev/learn/render-and-commit) and [Keeping Components Pure](https://react.dev/learn/keeping-components-pure)).（请参阅[渲染和提交](https://react.dev/learn/render-and-commit)以及[保持组件纯净](https://react.dev/learn/keeping-components-pure)）。

 [React-Managed Portal Element](https://julesblom.com/writing/ref-callback-use%20cases#react-managed-portal-element)

[useEffect 有时会在绘制之前触发](https://blog.thoughtspile.tech/2021/11/15/unintentional-layout-effect/)

在[`ReactDOM.flushSync`](https://react.dev/reference/react-dom/flushSync)中包装状态更新会选择退出状态更新批处理，并使 React 立即将更新应用到 DOM。它**同步刷新更新**。

## 

[React.memo](%E5%B8%B8%E8%A7%81%E7%9A%84%20React%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5%201692048329b080c98f83f6aae0bb0376/React%20memo%2016c2048329b0808985d0e5d759023dad.md)

## 避免重新渲染

- React 中，当父组件重新渲染时，默认情况下其所有子组件也会重新渲染，即使 props 和 state 没有发生变化
- 优化
    - 使用 `React.memo`
    - 优化父组件的状态管理
    - 使用 `useCallback` 和 `useMemo`
    - 使用 `key` 提升**列表渲染**速度
    - 避免匿名函数或者对象作为 props
    - 子组件作为 `children` ？？？缓存 `children`