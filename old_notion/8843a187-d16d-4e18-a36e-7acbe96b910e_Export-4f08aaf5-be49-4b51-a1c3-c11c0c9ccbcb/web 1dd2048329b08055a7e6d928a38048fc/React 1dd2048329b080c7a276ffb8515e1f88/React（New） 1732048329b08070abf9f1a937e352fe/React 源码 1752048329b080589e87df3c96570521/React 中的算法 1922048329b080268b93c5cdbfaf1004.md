# React 中的算法

## 位运算

二进制运算符将它们的操作数作为 32 个二进制位（0 或 1）的集合，并返回标准的 JavaScript 数值。

### **基础语法见：**

- [MDN 位运算符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Expressions_and_operators#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6)介绍
- [MDN 位运算API](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators#%E4%BD%8D%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6)

### **常见用法**

- **属性增加： `|`**
    - `currentLanes | Lane`
    - 取并集
- **属性检测： `&`**
    - `currentLanes & Lane`
    - 取交集
- **属性删除： `& ~`**
    - `AB = ABC & ~C`
    - 先反转删除的目标，将目标位的 `1 -> 0` 不需要删除的位都位 `1` ，这样取并集即可删除目标位的 `1` 了
- **属性比较**
    - 包含：`AB & B === B`
        - AB 当中包含 B（ `因为与 B 的交集，只会少于或者等于 B，等于就是包含` ）
    - 相等： `A === B`
    - 不包含： `AB & C === 0`

### **React 中的特殊用法**

- `取最高优先级`（最右边的1）
    
    ```jsx
    function getHighestPriorityLane(lanes: Lanes) {
      return lanes & -lanes;
    }
    /*
     * 1. 反转 lanes + 1 得 负lanes
     * 2. 负lanes 的特性就是保留最右边的 1
     * 3. 通过 & 取最右边的 1
     */
    ```
    
- `取最低优先级`（最左边）
    
    ```jsx
    function getLowestPriorityLane(lanes: Lanes): Lane {
      // This finds the most significant non-zero bit.
      const index = 31 - clz32(lanes);
      return index < 0 ? NoLanes : 1 << index;
    }
    /*
     * 1. clz32(lanes) 返回前导 0 的个数
     * 2. 31 - 前导 0 个数得出最左侧1在第几位
     * 3. 将 1 向左边移动到自己的位数即最低优先级是多少
     */
    ```
    

### 应用场景

- **Fiber 状态标志**
    - 当前 Fiber 对象的状态（如：是否需要更新、插入、删除等）。
    - `Placement` , `Update` , `Deletion`
- **lane 模型和优先级管理**
    - 通过 lane 模型，React 处理优先级高的任务，低优先级的任务会延后执行，优化渲染性能。
- **ExecutionContext 和任务上下文管理**
    - [变量定义](https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberWorkLoop.old.js#L263-L266)
        - `NoContext`  默认的空上下文，表示 React 未处于任何特殊阶段或模式
        - `BatchedContext` 表示 React 处于**批量更新模式**
        - `RenderContext` 表示 React 正在**协调阶段（Reconciliation/Render Phase）**，即构建新的 Fiber 树（Virtual DOM）
        - `CommitContext` 表示 React 处于**提交阶段（Commit Phase）**，即应用副作用到真实 DOM。
- **Tag 系统和组件类型标记**
    - 对不同类型组件的识别（例如函数组件、类组件等）
- **WorkUnit 和 WorkPhase 的标志位管理**
    - 通过位运算管理任务的工作单元和工作阶段。
    - **Idle**（空闲）、**Rendering**（渲染中）、**Committing**（提交中）等。
- **渲染模式与并发任务调度**
    - React 18 引入了不同的渲染模式（例如 **Concurrent Mode** 和 **Blocking Mode**）
- **事件系统优化与事件类型标记**
    - React 会为每种事件类型（click, focus, blur, input 等）分配一个位掩码
- **Suspense 和异步任务调度**
    - React 会为每个异步操作（如网络请求、数据加载等）分配一个 SuspenseContext 标志，表示当前的渲染是否依赖于某个异步任务。

```bash
作用：
- 合并（添加），如：合并上下文
- 检查，如：检查上下文
- 清除，如：清除上下文
```

## 深度优先遍历

**介绍**

- “一条道走到黑，碰壁回撤找新路”
- 参考：https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2

**React中的应用**

- 虚拟 DOM 的递归遍历
- Diffing 算法
    - 作为 Diffing 算法的基础
- Fiber 架构
    - 分成更小的 DFS，避免阻塞主线程
- 生命周期的调用顺序

## 堆排序

堆排序是利用二叉堆的特性, 对根节点(最大或最小)进行循环提取, 从而达到排序目的(堆排序本质上是一种选择排序), 时间复杂度为`O(nlog n)`

**React 中的主要应用**

- `scheduler`
    - 以最小堆堆形式存储任务
    - `taskQueue` - 最小堆
    - `timerQueue` - 最小堆

## 链表

是一种线性表，插入和删除操作更加高效，访问元素时需要遍历

具有 `.next` 属性，执行下一个节点。

**React 中的应用**

通常是环形列表，首位相连。目的是为了快速添加新的元素

- Fiber 链表
    - 任务分片：React 将渲染任务拆分成多个小任务，通过链表结构管理这些任务的执行顺序
    - 中断与恢复：链表结构允许 React 在渲染过程中中断任务，优先处理高优先级更新，之后再恢复
    - 高效更新：通过链表，React 可以快速定位需要更新的组件，减少不必要的渲染
- `Effect` 链表，内容为fiber对象
    - `fiber.nextEffect`: 单向链表, 指向下一个有副作用的 fiber 节点.
    - `fiber.firstEffect`: 指向副作用链表中的第一个 fiber 节点.
    - `fiber.lastEffect`: 指向副作用链表中的最后一个 fiber 节点.
- `updateQueue` 链表，存储将要更新的状态（update对象）
    - `fiber.updateQueue.pending`: 存储`state`更新的队列(链式队列), `class`类型节点的`state`改动之后, 都会创建一个`update`对象添加到这个队列中. 由于此队列是一个环形队列, 为了方便添加新元素和快速拿到队首元素, 所以`pending`指针指向了队列中最后一个元素
- 合并链表
    - fiber 构建阶段（或reconciler）
        - `fiber.updateQueue.shared.pending` → `fiber.updateQueue.firstBaseUpdate`
    - fiber 构建阶段（或reconciler）
        - `hook.queue.pending` → `hook.baseQueue`

## 堆栈

- **Context 状态管理**
    - 体来说是使用`Context.Provider`, `Class.contextType`, `Context.Consumer`等`api`
- **executionContext 执行上下文**

由于`reconciler`过程是一个深度优先遍历过程, 对于`fiber树`来讲, 向下探寻(`beginWork`阶段)和向上回溯(`completeWork`阶段)天然就和栈的入栈(`push`)和出栈(`pop`)能够无缝配合(context 机制就是在这个特性上建立起来的).

## 调和算法

**作用：高效找出虚拟DOM的差异，最小化真实DOM操作**

单节点的逻辑比较简明, 先直接看[源码](https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactChildFiber.old.js#L1129-L1204)

```jsx
  // 签名
  function reconcileSingleElement(
    returnFiber: Fiber, // workInProgress
    currentFirstChild: Fiber | null, // current.child
    element: ReactElement, // nextChildren = workInProgress.pendingProps
    lanes: Lanes,
  ): Fiber {
```

**核心逻辑**

算法的核心，本质上就是 `旧Fiber` 和 `新ReactElement` 比较，看看是否能复用 `旧Fiber` 否则根据 `ReactElement` 创建 `Fiber`

- 单节点比较
    - 更新的时候，进行比较
    - 先比较 `key` 再比较 `type` ，都相同时，进行复用，只更新属性（DOM节点进行复用，属性合并）
- 数组和可迭代节点比较
    - 先遍历最长公共序列，即：遍历最长的那个序列，开头 `key` 与另一个序列 `key` 相同的那一部分
        - 会存在三种情况：
            - 1 旧序列遍历完
            - 2. 新序列遍历完
            - 3. 都没有遍历完， `key` 不一样了。
        - 如果新序列先遍历结束，旧的那部分剩余节点打 `Deletion` 标记
        - 如果旧序列先遍历结束，新序列剩余部分打 `Placement` 标记
    - 再次遍历，最长序列剩余部分
        - 优先匹配旧序列中 `key` 相同的那一部分进行复用
        - 第二次匹配完后， 旧序列 没有匹配的部分打 `Deletion` 比较