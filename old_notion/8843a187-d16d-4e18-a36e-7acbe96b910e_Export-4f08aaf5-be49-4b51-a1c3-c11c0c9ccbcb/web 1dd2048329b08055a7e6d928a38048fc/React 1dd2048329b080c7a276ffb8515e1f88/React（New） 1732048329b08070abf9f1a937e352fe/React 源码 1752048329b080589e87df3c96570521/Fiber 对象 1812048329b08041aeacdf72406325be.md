# Fiber 对象

`react@18.2` 定义在 [ReactInternalTypes.js](https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactInternalTypes.js#L67-L194)

粗暴理解：fiber 节点存储了每个任务和当前的状态及如何执行

```jsx
export type Fiber = {
   /** 
   * ### 标识（Identification）
   * 这些字段用于标识 Fiber 的类型、唯一性以及具体的组件信息。
   */
  tag: WorkTag,              // 节点类型（如 FunctionComponent、ClassComponent、HostComponent 等）
  key: null | string,        // 组件 key（用于 diff）
  elementType: any,          // 元素类型（如 JSX 组件类型）
  type: any,                 // 组件类型（如 FunctionComponent、ClassComponent）
  stateNode: any,            // 对应的 DOM 节点或组件实例

  /** 
   * ### 树结构 & 链表（Tree & Linked List Structure）
   * 这些字段用于维护 Fiber 树的层级和兄弟关系，使得 React 可以进行 **增量更新** 和 **任务调度**。
   */
  return: Fiber | null,      // 指向父 Fiber 节点（return 代表 “返回”）
  child: Fiber | null,       // 指向第一个子 Fiber 节点
  sibling: Fiber | null,     // 指向下一个兄弟 Fiber 节点
  index: number,             // 子节点在兄弟节点中的索引（用于 diff 过程）

  /**
   * ### 状态 & 更新（State & Updates）
   * 这些字段存储组件的状态和 props 相关信息，用于管理组件的更新逻辑。
   */
  pendingProps: any,         // 本次更新的 props（即 `render` 时传递的新 props）
  memoizedProps: any,        // 上一次渲染的 props（用于 `memoization` 进行优化）
  updateQueue: mixed,        // 存储状态更新队列（`useState` 或 `setState` 触发的更新）
  memoizedState: any,        // 已计算的 `state`（最终渲染使用的 state）
  dependencies: Dependencies | null, // 依赖项（比如 `useContext` 的依赖关系）

  /**
   * ### 副作用 & 更新路径（Effects & Side Effects）
   * 这些字段用于管理 React 的 **副作用系统**，决定哪些节点需要更新或删除。
   */
  flags: Flags,              // 标记当前 Fiber 节点的副作用类型（如 `Update`、`Placement`、`Deletion`）
  subtreeFlags: Flags,       // 子树的副作用标记（用于向上冒泡副作用）
  deletions: Array<Fiber> | null, // 记录需要删除的子 Fiber 节点（用于 Diff 阶段）
  nextEffect: Fiber | null,  // 指向下一个需要执行副作用的 Fiber 节点（commit 阶段用）
  firstEffect: Fiber | null, // 指向子树中第一个有副作用的 Fiber
  lastEffect: Fiber | null,  // 指向子树中最后一个有副作用的 Fiber

  /**
   * ### 性能测量（Performance Measurement）
   * 这些字段仅在 **开发模式 & 调试工具** 中启用，用于性能分析。
   */
  actualDuration?: number,   // 记录该 Fiber 在本次更新中的实际执行时间
  actualStartTime?: number,  // 记录该 Fiber 开始执行的时间点
  selfBaseDuration?: number, // 该 Fiber 自身的基础执行时间
  treeBaseDuration?: number, // 整个子树的基础执行时间

  // 引用 & 模式
  ref: null | (((handle: mixed) => void) & {_stringRef?: string}) | RefObject, // 组件 ref
  mode: TypeOfMode,          // Fiber 运行模式（如 Concurrent Mode）

  /**
   * ### 调度（Scheduling）
   * 这些字段用于 React 的 **并发模式** 和 **调度系统**，决定更新的优先级和任务管理。
   */
  lanes: Lanes,              // 当前 Fiber 节点的优先级 lanes（如 Sync、Transition 等）
  childLanes: Lanes,         // 子树中最高优先级的 `lanes`（用于优化调度）

  /**
   * ### 双缓存机制（Double Buffering）
   * `alternate` 是 React **双缓存（Double Buffering）** 的核心机制。
   */
  alternate: Fiber | null,   // 指向上一次渲染的 Fiber（双缓存机制）

  /**
   * ### 调试（Debugging）
   * 这些字段仅在 **开发模式** 中启用，用于 `React DevTools` 和调试信息。
   */
  _debugSource?: Source | null,  // 代码来源（用于调试）
  _debugOwner?: Fiber | null,    // 该 Fiber 所属的 React 组件
  _debugIsCurrentlyTiming?: boolean, // 是否正在进行性能测量
  _debugNeedsRemount?: boolean,  // 是否需要重新挂载
  _debugHookTypes?: Array<HookType> | null, // 记录 hook 类型
};
```

其中比较重要的概念：

- 树形结构和链表
- 双缓存
    - `alternate`
    - `current` ??????? 待确认
- 任务调度
- 状态管理
- 副作用处理

**重点解析：**

1.	**Fiber 采用了链表结构**：

•	return 指向 **父节点**

•	child 指向 **第一个子节点**

•	sibling 指向 **下一个兄弟节点**

•	这种结构支持 **深度优先遍历（DFS）**，可以逐步渲染子树。

2.	**双缓存机制（Double Buffering）**：

•	alternate 指向上一次渲染的 Fiber，React 通过 current 和 workInProgress 进行**对比更新**，减少不必要的 DOM 操作。

3.	**副作用系统（Effect List）**：

•	flags 记录**当前 Fiber 是否需要更新**

•	nextEffect、firstEffect、lastEffect 记录副作用链表，React 在 **commit 阶段** 处理它们。

4.	**任务调度（Scheduling）**：

•	lanes 记录当前 Fiber 的**优先级**

•	childLanes 记录子树中的最高优先级任务

•	这些字段用于 **Concurrent Mode** 进行任务拆分和时间切片。

5.	**调试信息**：

•	_debugSource、_debugOwner 仅用于 **开发模式**，在 React DevTools 中用于可视化 Fiber 树。

**结论**

Fiber 是 React 16+ 架构的核心数据结构，提供：

•	**增量更新（Incremental Rendering）**

•	**任务调度（Scheduler & Lanes）**

•	**双缓存机制（WorkInProgress & Current）**

•	**并发模式支持（Concurrent Mode）**

•	**副作用系统（Effect List）**

这使得 React 具备了更高效的渲染能力，并支持未来的发展方向（如 React Server Components）。

## **线性流程总结**

在 React 的 **并发模式（Concurrent Mode）** 下，React 需要管理多个更新的优先级。因此，它引入了 lanes 机制，用于控制更新的调度优先级。alternate 则用于双缓存机制（Double Buffering），在 Fiber 树的构建过程中提供优化。

### **1️⃣ 组件初始化**

**初始化 Fiber 节点，准备渲染**

•	pendingProps：存储组件的初始 props

•	memoizedState：存储组件的初始 state

•	lanes：初始化优先级（默认是 NoLanes）

•	childLanes：子树的最高优先级（默认是 NoLanes）

•	alternate：指向旧的 Fiber（null，因为是第一次渲染）

### **2️⃣ 触发更新**

**用户交互（如 setState）或 props 变化**

•	updateQueue 记录新的 state

•	**计算更新优先级，赋值 lanes**

•	如果 Fiber 有子组件，则 **更新 childLanes**，确保 React 处理整个子树的最高优先级

示例：

```jsx
<button onClick={() => setCount(count + 1)}>Increase</button>
```

➡ lanes 变为 SyncLane（同步更新）

### **3️⃣ 调度阶段（Scheduler）**

**React 根据 lanes 决定何时执行更新**

•	SyncLane（同步）：立即更新，如 setState

•	TransitionLane（过渡）：用于 startTransition，可以被中断

•	IdleLane（空闲）：低优先级任务，如日志记录

➡ **React 选择最合适的 lanes 进行更新**

### **4️⃣ 计算新状态**

**Reconciliation 阶段**

•	updateQueue 处理更新

•	memoizedState 计算最新 state

•	**对比 alternate（旧 Fiber）**，决定是否需要更新 DOM

➡ **如果 state 变化，React 继续渲染；否则跳过（优化性能）**

### **5️⃣ 提交阶段（Commit）**

**应用最终 state 并更新 Fiber**

•	lanes **被清空**

•	memoizedProps & memoizedState 更新为最终值

•	**alternate 交换：**

•	旧 Fiber 变为 alternate

•	新 Fiber 作为当前渲染树

**双缓存（Double Buffering）优化**：

```jsx
alternate = oldFiber;
```

## 重点属性

- `fiberRoot`
    - `current` 当前浏览器渲染出来的fiber树
- `HostRootFiber.alternate` 正在构造的fiber树 → 也叫做 `workInProgress`

## 初次流程

- `updateContainer`
    
    `enqueueUpdate` ????
    
- `scheduleUpdateOnFiber`
- `performSyncWorkOnRoot`
- `renderRootSync`
    - `workLoopSync`
        - `performUnitOfWork`
            - `beginWork`
                - `updateXXX`函数: `updateClassComponent`
                    - `renderWithHooks`
                    - `reconcileChildren`
            - `completeUnitOfWork`
                - `completeWork`
                    - `createInstance`
- `commitRoot`

## 更新

- 入口： `scheduleUpdateOnFiber`
    - `markUpdateLaneFromFiberToRoot`
    - 对比更新： `ensureRootIsScheduled`
        - ?? `renderRootSync`
            - `workLoopSync`
                - `performUnitOfWork`
                    - `beginWork`
                        - `bailoutOnAlreadyFinishedWork`
                        - `updateXXX`函数
                            - `bailoutOnAlreadyFinishedWork`
                            - `reconcileChildren`
                    - `completeUnitOfWork`

**小结一下：**

- `fiberRoot.current`指向与当前页面对应的`fiber树`, `workInProgress`指向正在构造的`fiber树`.
- **共用子元素** `workInProgress.child = current.child`. 所以在进入`循环构造`之前, `HostRootFiber`与`HostRootFiber.alternate`共用一个`child`(这里是`fiber(<App/>)`)。
- 
- `workInProgress`和`current`都视为指针
- `workInProgress`指向当前正在构造的`fiber`节点
- `current = workInProgress.alternate`(即`fiber.alternate`), 指向当前页面正在使用的`fiber`节点.

## fiber 渲染

- 起始： `commitRoot`
    - `runWithPriority`
    - `commitRootImpl`
        - `commitBeforeMutationEffects`
            - `commitBeforeMutationEffectOnFiber`
            - `scheduleCallback`
            - `flushPassiveEffects`
        - `commitMutationEffects`
            - `commitDetachRef`
            - `commitPlacement`
            - `commitWork`
            - `commitDeletion`
        - `commitLayoutEffects`
            - `commitLayoutEffectOnFiber`
                - 核心逻辑
                - `生命周期调用`
                - `commitUpdateQueue`
                - `commitMount`
            - `commitAttachRef`
        - `detachFiberAfterEffects`
        - 检测异步任务： `ensureRootIsScheduled`
        - 检测同步任务： `flushSyncCallbackQueue`

问

- 渲染优先级
- 调度优先级

```
// 1. fiber节点自身状态相关
  pendingProps: any,
  memoizedProps: any,
  updateQueue: mixed,
  memoizedState: any,
这一段，还他妈的没有理清楚

  // 2. fiber节点副作用(Effect)相关
  flags: Flags,
  subtreeFlags: Flags, // v17.0.2未启用
  deletions: Array<Fiber> | null, // v17.0.2未启用
  nextEffect: Fiber | null,
  firstEffect: Fiber | null,
  lastEffect: Fiber | null,
```

这里我们可以结合前文[状态与副作用](https://7km.top/main/state-effects), 从`fiber`的视角去理解`状态Hook`与`副作用Hook`的区别.

woc，到底咋区分啊？

## hook

调用顺序

- `updateFunctionComponent`
    - `renderWithHooks`