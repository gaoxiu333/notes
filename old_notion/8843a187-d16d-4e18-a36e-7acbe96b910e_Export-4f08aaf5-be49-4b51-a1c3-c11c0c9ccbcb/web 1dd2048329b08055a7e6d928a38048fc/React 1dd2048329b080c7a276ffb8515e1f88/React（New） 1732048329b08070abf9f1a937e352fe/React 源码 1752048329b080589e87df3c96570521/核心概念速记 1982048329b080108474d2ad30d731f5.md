# 核心概念速记

## 时间切片

- 核心方法
    - **`performWorkUntilDeadline`**
    - 时间切片：
        - 利用事件循环的异步方法： `setImmediate` 、 `MessageChannel` 、 `setTimeout`
        - 执行： `scheduledHostCallback`
        - 循环： `schedulePerformWorkUntiDeadline`

## 两大工作循环

- 任务调度循环
    - 不关心任务具体执行，任务的具体执行依赖 `performSyncWorkOnRoot` or `performConcurrentWorkOnRoot`
    - **算法：二叉树中的最小堆**
- fiber 构建循环
    - 构建fiber树
    - 是任务调度循环中的子循环。
    - 做了哪些事情？fiber树构造，dom渲染，调度检测？？？？？？？
    - **算法：链表中的深度优先遍历算法**

还有一个循环，在commit阶段，就是把最新的fiber树渲染到页面上，执行task？

## 高频对象

- react 包
    - `ReactElement` 对象，由 JSX 生成
        - 在代码编译阶段，由 `React.createElement` 创建
        - 最终的内存结构是一个 伪链表结构，因为子节点，可能是一个数组或者可迭代对象，不是严格意义上的树或者链表。
        - 关键属性
            - key：默认为 `null` 除非开发者赋值。
            - type：决定了 react 如何生成一个fiber，比如时 调用 `function` 还是 `class`
- react-reconciler 包
    - fiber 对象，见fiber对象。
        - 关键属性： `update` 和 `updateQueue` 对象
            - 链表结构
            - 存储任务队列
    - hook 对象
- scheduler 包
    - task 对象
        - 是一个最小堆

## reconciler 运作流程

核心概括：

1. 输入
2. 注册任务
3. 执行任务回调
4. 输出

核心方法： `scheduleUpdateOnFiber`

解释：

reconciler的核心也是唯一入口是从调用 `scheduleUpdateOnfiber` 开始作为输入，这个一般是从哪里开始？

然后在基于 `scheduler` 注册调度任务，由 `scheduler` 安排任务优先级，决定每个任务的执行时机。

最后呢，通过 `react-dom` 渲染dom节点。

## React 应用的启动过程

启动的方式在 react@17有三种

- legacy
- blocking
- concurrent

到了 react@18就剩下两种了

- `createRoot`
- `hydrateRoot`

创建全局对象

- ReactDom 对象？？？？？？？？？？这个到底是什么啊？
    - 将fiberroot挂载到 `this._internalRoot`
    - 有 render 和 unmount 方法，且会调用 updateContainer
- fiberRoot
    - 存储全局上下文，以及fiber循环中的各种状态
        - 比如呢？？
            - mode，批量更新模式还是传统模式
            - current 指向 HostFiber
            - containerInfo，指向react的 dom 根容器
            - 
- HostFiber
    - react 中的第一个fiber
        - stateNode，指向FiberRoot
        - mode，决定后续fiber的mod类型
- 核心函数执行
    - `updateContainer`
        - 串联 react-dom和react-reconciler
            - 主要是创建了 update 对象？？？
        - 它还调用了 `scheduleUpdateOnfiber`

总结：

react 启动过程中，创建了三个关键的全局对象，并绘制了他们在内存中的引用关系。最后调用 updateContainer，进入 react-reconciler 并调用 scheduleUpdateOnFbier 开始协调流程

## 优先级管理

两套优先级体系，一套转换体系。

两套

- fiber 优先级
- 调度优先级

转换

- 优先级等级

三种优先级相互独立，在不同的代码中

- LanePriority
- SchedulerPriority
- ReactPriorityLevel

接下来的核心分为两块

- 调度原理
- fiber 构建

## React 调度原理

workLoop 

这里是任务消费的地方，其中 `performWorkUntilDeadline` 又是核心方法。

- 时间切片
    - 根据当前时间
    - 时间切片周期：默认 5ms
    - 每一个 task 执行的时候都检查是不是超过了这个 5ms
- 可中断渲染
    - 根据 `navigator.scheduling.isInputPending()` 判断是否有用户交互事件
- 以上的核心逻辑在 scheduler 中

核心函数 `performWorkUntilDeadline`

- 利用 `MessageChanel` 循环自身。来形成一个react的核心，调度循环。

任务结构

- `taskQueue`  每次取优先级最高的执行，位于堆顶的任务。
- `timerQueue` 延时任务的队列
- 核心原理：每次检查延时任务队列，有没有过期任务，将过期任务合并到 `taskQueue` ，根据什么排序来着？

疑问：

messageChanel循环和workloop中的while循环，分别对应哪些核心知识

```bash
1. scheduleCallback  (任务调度)
      ↓
2. requestHostCallback (请求宿主环境执行调度回调)
      ↓
3. messageChannel  (触发 `performWorkUntilDeadline`)
      ↓
4. performWorkUntilDeadline (执行 `flushWork`)
      ↓
5. workLoop (执行 Fiber 任务)
      ↓
6. shouldYield? (是否中断)
      ├── 否 → 继续执行
      ├── 是 → 调用 messageChannel 重新调度下一帧 (回到步骤 3)
      ↓
7. 任务完成，退出
```

## Fiber 基础

构建fiber是 taskQueue 中的一个任务

但它也是 fiber 树构建循环，两大循环中的一种。

构建步骤

1. fiber 构建之前也借助了大量的全局变量，重点如下：
    1. `executionContext` 全局上下文
    2. `workInProgress` 当前处理中的fiber节点
    3. 一系列优先级： `woriInprogressRootrenderLanes` , `suttreeRenderLanes` …
    4. `currentEventTime` 当前时间
2. 双缓冲技术
    1. fiber.current
    2. fiber.alternate，workInProgress 一般工作在这里。
3. 全局变量的作用
    1. fiber在中断构建可以在下次任务继续，所依赖的就是这一组全局变量
    2. `prepareFreshStack` 是用来重置这些全局变量的

## Fiber 树构造（初次）

发生条件

1. 初次渲染/创建
2. react触发更新时

当前就是初次内容：

1. 入口为调用 `updateContainer` 然后创建一个 fiber 任务，调用 `scheduleUpdateOnFiber` 进入调和阶段
2. 调和阶段执行 `performSyncWorkOnRoot` 开始构建fiber
    1. 深度优先
        1. 开始阶段 beginWork
        2. 回溯阶段：completeWork
        3. 一个fiber构建需要经过以上两个阶段
3. beginWork
    1. 这个函数做了啥呢？
    2. 首先根据 ReactElement 创建fieber阶段，
    3. 设置 return、sibling指针，尤其是sibling，只存在指针，但不会构建子节点的fiber。
    4. 然后打标记 `fiber.flags` , 增删改等，这里肯定是增
    5. 设置 `stateNode` ，挂载实例
    6. **注意节点：这里也是 hooks 组件被调用的地方，clss组件执行 render 的地方！！！**
    7. 所以这个地方，初始化了状态，effect等加入到 memoizedState
4. completeUnitOfWork
    1. 这个阶段，发生在？？
    2. 这个阶段会识别 beginWrok 打的标记，根据需要是否对节点进行操作比如 append dom等操作
    3. 给 fiber 阶段创建 dom 实例，挂载到 stateNode，然后设置 dom 属性，包含合成事件
    4. 修改 effect 链表，将子节点的副作用都放在父节点 fisterEffect和lastEffect上面
    5. 然后执行 completeWork
    

performUnitOfWork 执行后调用 beginWork 构建fiber，workInProgress 随着 beginWork 的调用，不断的指向当前构建的fiber，**一条道走到黑** 等到遇到没有子节点的 jsx 对象时，开始回溯，调用 completeUnitOfWork

注意：从最低处回溯，也就是执行完 complateWork，检查当前节点是否有兄弟元素，有的话先改变 workInProgress 到兄弟元素，重新调用 beginWork，开始构建兄弟元素的fiber，一样的，一条道走到黑开始 complateWork

最后将新树放在 `fiberRoot.finishedWork` 等待 `commitRoot` 阶段

## Fiber 树构造（更新）

和创建差不多，但是为了优化性能，做了fiber diff。

对比的核心函数 `markUpdateLaneFromFiberToRoot`

- 查找更新过程：从当前fiber开始，向上遍历所有父节点，一直到 rootFiber，检查current和alterNate中的lan，决定当前节点是否更新

同样的fiber更新也经过 beginWork和completeWork

- beginWork
    - 检查优先级，如果有 `alternate` 并且没有更新的优先级匹配上，直接执行回溯阶段
    - **更新对比：新的 ReactElement 和 旧的fiber 对比**

核心就是多了两个对比，一个是优先级，一个是新元素和旧fiber对比，也算是能省则省。

## Fiber 渲染阶段

- `fiberRoot.finishedWork` 这是之前构建的新fiber，还没有绘制到浏览器。

核心方法： `commitRoot` , `commitRootImpl`

commitRootImpl 分为三个阶段

- 渲染前
    - 初始化变量，重置全局变量，比如 workInProgressRoot
    - 更新要执行的副作用链表
- 渲染1: dom 突变前
    - 执行副作用，主要是标记为 `Snapshot` 和 `passive` 标记的副作用
    - 典型：滚动条快照，useEffect 中的回调函数
- 渲染2: dom突变，界面变化
    - 执行 `Placement Update Deletion`  等标记的副作用
- 渲染3: layout 阶段
    - 执行 `Update | Callback` 标记的副作用
- 渲染后：重置并清理

## 状态和副作用

这里需要背几个状态，和useEffect的执行时机，嗯。不复杂倒是