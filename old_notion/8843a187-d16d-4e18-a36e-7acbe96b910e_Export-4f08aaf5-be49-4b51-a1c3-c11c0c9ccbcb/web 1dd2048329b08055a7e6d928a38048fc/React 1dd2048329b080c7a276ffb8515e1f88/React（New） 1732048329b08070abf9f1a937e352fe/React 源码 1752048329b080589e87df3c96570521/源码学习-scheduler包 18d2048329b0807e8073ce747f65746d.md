# 源码学习-scheduler包

**理解任务调度机制**

调度系统，用于控制任务的优先级、协调任务的执行顺序

- **目标**：
    - 掌握 React 如何调度任务，实现时间切片和优先级管理。
- **关键点**：
    - 任务队列的结构（最小堆）和优先级机制（Immediate/UserBlocking/Normal/Idle）。
    - 时间切片（Time Slicing）和任务中断/恢复逻辑。
    - `requestIdleCallback` 的 polyfill 和任务调度循环。
- **为什么此时学**：
    - 协调器（Reconciler）依赖调度器管理任务，提前理解调度逻辑有助于后续学习。
- **理解**
    - 它负责任务调度，优先级管理，时间切片等。scheduler实现了任务队列，根据优先级决定任务的执行顺序，并在适当的时候让出主线程，以避免阻塞用户交互，有任务队列的管理、优先级处理、时间切片逻辑，如workLoop、advanceTimers、shouldYieldToHost等方法。协调器在调度更新时，会调用scheduler的API，比如unstable_scheduleCallback，将任务加入队列，由scheduler决定何时执行。

## API

**源码**

- 入口：[packages/scheduler/src/forks/Scheduler.js](https://github.com/facebook/react/blob/v18.2.0/packages/scheduler/src/forks/Scheduler.js)

**核心方法：**

- 任务调度
    - `unstable_scheduleCallback` 根据优先级调度任务
    - `unstable_cancelCallback` 取消任务
- 调度循环
    - `workLoop`
    - `advanceTimers` 将 timerQueue 中到期的延迟任务转移到 taskQueue
- 优先级控制
    - `unstable_runWithPriority` 指定优先级上下文中执行函数
    - `unstable_wrapCallback` 包装回调函数，继承父级优先级
- 时间切片
    - `shouldYieldToHost` 基于时间阈值和 `isInputPending` 判断是否让出主线程
- 宿主环境适配
    - `requestHostCallback` 决定使用 `MessageChannel` 还是 `setImmediate/setTimeout`

**这里涉及较多的核心思想，需要一一熟悉温习～**

## 理解

- 每次更新时重新绘制整个应用程序
- 渲染并不是一件坏事，React 通过它知道是否需要对DOM进行任何更改
- 渲染必须是纯粹的，并且不会导致任何破坏

### 内部实现

**任务对象结构**

- 最小堆（小顶堆）
- 通过 `priorityLevel` 和 `expirationTime` 进行堆排序，高优先级和过期任务优先出队
- 通过 二叉堆算法高效维护

```jsx
{
  id,                 // 唯一标识
  callback,           // 要执行的回调函数
  priorityLevel,      // 优先级
  startTime,          // 任务调度的起始时间
  expirationTime      // 任务过期时间，用于排序
}
```

**performWorkUntilDeadline**

调度的核心循环方法，负责从任务队列中提取任务并在时间切片内执行

**关键方法：**

- `shouldYieldToHost: 判断时间是否用尽，决定是否暂停任务`
- `requesthostCallback: 注册调度回调`

### 优先级模型

- `ImmediatePriority: 紧急任务，立即执行`
- `UserBlockingPriority: 用户交互任务，如输入和点击`
- `NormalPriority: 默认任务`
- `LowPriority: 后台任务`
- `IdlePriority: 仅在空闲时执行`

### 总结

**核心目标**

- 利用时间切片提升任务执行的流畅性
- 通过优先级机制确保关键任务优先完成

**重要方法**

- `performWorkUntilDeadline`
- `shouldYieldToHost`
- `requestHostCallback`

**关键设计**

- 任务队列：基于最小堆，确保任务按照优先级顺序执行
- 时间切片：通过 `deadline` 和 `shouldYieldToHost` 分割任务，避免阻塞主线程

## 数据结构

**最小堆**

任务调度的基础，主要用于管理任务队列

- `push(heap,node)` 插入任务到最小堆，并上浮维护堆结构
- `peek(heap)` 获取堆顶任务（**最紧急任务**），但不删除
- `pop(heap)` 取出堆顶任务，从堆中删除，并下沉维护堆结构

**任务对象**

- taskQueue(任务队列) → 用于存储调度中的任务，按照 `expirationTime` 过期时间排序
- timerQueue(定时任务队列) → 用于存储延迟执行的任务，按照 `startTime` 计划开始时间排序

```jsx
var newTask = {
  id: taskIdCounter++,  // 任务唯一 ID，自增
  callback,             // 任务的回调函数
  priorityLevel,        // 任务优先级
  startTime,            // 任务开始执行的时间
  expirationTime,       // 任务的超时时间（过期时必须执行）
  sortIndex: -1,        // 用于排序的索引
};

{
  id,         // 任务唯一 ID
  callback,   // 任务的回调函数
  priority,   // 任务优先级（数值越小，优先级越高）
  startTime,  // 任务计划开始时间（基于 performance.now()）
  expirationTime // 任务的超时时间（超过该时间必须执行）
}
```

**任务**

- 可立即执行任务（同步？）已达到 startTime
- 高优先级任务，expirationTime 即将超时任务
- 渲染任务、状态更新任务（react任务）