# React 初始化流程

说明：一下是 `React@18.2` 的代码执行流程

## 初始化阶段

1. `ReactDOM.createRoot` 调用
    1. 初始化一些配置，比如是否开启严格模式
2. 调用 `createContainer`
    1. 创建： `FiberRootNode` 调用 `createFiberRoot`
        1. 实例化 `FiberRootNode`
    2. 创建： `HostFiber` 调用 `createHostRootFiber`
    3. 双向关联 hostFiber 和 FiberRootNode
    4. 创建临时缓存 `pooledCache` 渲染后移除
    5. 创建缓存 `memoizedState`
    6. 初始化更新队列： `initializeUpdateQueue`
    7. 返回初始化后的 `FiberRootNode`
3. 通过调用 `listenToAllSupportedEvents` 注册监听器
4. 返回 `ReactDOMRoot` 实例，其实还是 `FiberRootNode`

这段逻辑完成了 FiberRootNode 和 HostFiber 的创建、状态初始化、缓存设置，为 React 的更新和调度机制提供了运行时环境。

**小结：**

- `FiberRootNode`
    - React 的根容器
    - 管理 Fiber 树
    - 存储任务调度状态
    - 关联真实DOM容器
    
    ```jsx
    FiberRootNode {
      containerInfo: <DOM 节点>,
      current: <根 Fiber>,
      pendingLanes: <更新优先级队列>,
      hydrate: <是否为服务端渲染>,
      finishedWork: <完成的 Fiber 树>,
      // ... 其他调度和状态字段
    }
    ```
    
- `HostFiber`
    - 整个Fiber树的起点，tag为HostRoot
    - 维护全局应用状态： `updateQueue`
    - 树结构管理： `child` `sibling` `return`
    
    ```jsx
    Fiber {
      tag: HostRoot,           // 表示根节点类型
      stateNode: <FiberRootNode>, // 指向 FiberRootNode，双向关联
      updateQueue: <更新队列>,  // 存储更新任务
      child: <子节点 Fiber>,    // 树结构连接
      // ... 其他运行时信息
    }
    ```
    

### render 方法

调用 `updateContainer`

- 添加优先级
- 上下文管理

调用 `createUpdate` 创建更新对象

```tsx
function createUpdate(eventTime, lane) {
  return {
    eventTime: eventTime,    // 更新触发的时间，用于调度计算优先级。
    lane: lane,              // 更新的优先级（由调度器计算）
    tag: UpdateState,        // 表示更新的类型，例如状态更新（UpdateState）、强制更新（ForceUpdate）等。
    payload: null,           // 存储具体的更新内容，例如新的状态、虚拟 DOM 或组件树。
    callback: null,          // 可选的回调函数，更新完成后会执行。
    next: null               // 指向下一个更新，用于形成单链表结构的更新队列。
  };
}
```

调用 `enqueueUpdate` 将更新对象加入到fiber的更新队列

- `fiber.updateQueue` 当前fiber节点的更新队列，待处理
- `fiber.updateQueue.shared` 共享的更新队列
- `fiber.sharedQueue.pending` 指向更新链的最后一个节点，方便追加更新

**performWorkUntilDeadline 方法**

- 时间切片：
    - 利用事件循环的异步方法： `setImmediate` 、 `MessageChannel` 、 `setTimeout`
    - 执行： `scheduledHostCallback`
    - 循环： `schedulePerformWorkUntiDeadline`

**flushWork 方法**

- 执行 `workloop`
- 排序 `timerQueue` 并将超时任务加入 `taskQueue`
- 取出 `taskQueue` 第一个任务
- 如果 taskQueue 没有可执行任务，setTimeout 执行 timerQueue 中的任务。
- 简单来说就是通过最小堆的顺序执行任务

**performConcurrentWorkOnRoot 方法**

- 是否启用时间切片，本质上就是同步执行和异步循环任务

直接来一个总结吧：

- `render` → `updateContainer`
- `performWorkUntilDeadline` → `flushwork` → `workloop` → `workLoopSync`
- `performUnitOfWork` → `beginWork`

## 无论如何 Fiber 的主要职责记一下

- `_reactInternals` 上下文的fiber