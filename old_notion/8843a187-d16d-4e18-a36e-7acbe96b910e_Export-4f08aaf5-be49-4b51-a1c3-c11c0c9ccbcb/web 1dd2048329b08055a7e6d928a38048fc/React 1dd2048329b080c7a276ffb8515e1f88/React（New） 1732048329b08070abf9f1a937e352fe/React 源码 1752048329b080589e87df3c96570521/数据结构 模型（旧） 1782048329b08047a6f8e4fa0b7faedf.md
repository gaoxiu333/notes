# 数据结构/模型（旧）

## update 对象（状态更新的基本单元）

Update 对象是描述一次状态更新的原子单元。每次状态更新（如 setState）都会创建一个 Update 对象，该对象保存了状态更新的关键信息。

update 对象和 updateQueue 的关系，用图表表示 需要尽快学习

createUpdate 函数

```jsx
export function createUpdate(eventTime: number, lane: Lane): Update<*> {
  const update: Update<*> = {
    eventTime,     // 创建更新的时间（用于优先级计算）
    lane,          // 更新所属的优先级车道
    tag: UpdateState, // 更新类型（UpdateState | ReplaceState | ...）
    payload: null,  // 更新负载（setState 的第一个参数）
    callback: null, // setState 的第二个回调参数
    next: null,     // 指向下一个 Update 的指针
  };
  return update;
}
```

**payload**:

- 存储实际的更新内容。可以是：
    - **对象**（如 { count: 1 }），React 会将新对象与当前状态合并。
    - **函数**（如 (prevState) => ({ count: prevState.count + 1 })），函数式更新，React 会调用此函数来计算新状态。

## updateQueue(更新队列)

- 存储 setState 任务，用于管理组件状态更新
- 作用：按优先级存储 update，批量计算 newState，减少重复渲染

**数据结构**

```jsx
const updateQueue = {
  baseState: { count: 0 },                  // 记录上一次提交的 state，`commit` 阶段同步 `memoizedState`。
  firstBaseUpdate: Update<State> | null,    // 低优先级更新队列的头部，渲染前将 `shared.pending` 转移到这里。  
  lastBaseUpdate: Update<State> | null,     // 低优先级更新队列的尾部，新 update 追加到 `lastBaseUpdate.next`。
  shared: {                                 // 共享的 update 队列，所有新 update 先存入这里等待调度。
    pending: Update<State> | null,          // 记录待处理的 update 链表，`setState` 触发时追加，渲染前转移到 `firstBaseUpdate`。
  },
  effects: Array<Update<State>> | null,     // 存储 update 触发的副作用，`commit` 阶段执行 `useEffect` 回调等。  
};
```

updateQueue 作用于每一个 Fiber，是一个链式结构，是组件级别的setState任务管理器

## taskQueue(任务队列)

- 存储可以立即执行的任务（高优先级的setState任务）
- 作用：任务调度系统中的主要执行队列，按照 expirationTimer 进行排序

**数据结构**

```jsx
const task = {
  id: taskIdCounter++,    // 任务唯一 ID
  callback,               // 任务回调函数
  priorityLevel,          // 任务优先级
  startTime,              // 任务开始时间
  expirationTime,         // 任务过期时间
  sortIndex: expirationTime, // 排序依据
};
```

React 通过 taskQueue 确保优先级高的任务先执行，避免 UI 卡顿

## timerQueue(定时任务队列)

- 存储未来某个时间才执行的任务，startTimer>now的setState任务
- 作用：等待 startTime 触发后，将任务移动到 taskQueue，然后执行

**数据结构**

```jsx
const timerTask = {
  id: taskIdCounter++,
  callback,
  priorityLevel,
  startTime,             // 任务执行时间
  expirationTime,        // 超时时间
  sortIndex: startTime,  // 按 startTime 进行排序
};
```

主要用于 setTimeout 任务，确保任务不会提前执行

## syncQueue(同步任务队列)

- 存储处于 render 阶段的同步 setState 任务
- 作用：确保当前 render 期间的setState不会中断，并在 commit 阶段应用

**数据结构**

```jsx
const syncQueue = [update1, update2, update3]; // 任务数组
```

react 18 中，在render阶段不会直接触发 updateQueue，而是先存到syncqueue，然后在 commit 阶段批量更新

## effectList(副作用队列)

- 存储 useEffect/useLayoutEffect产生的副作用
- 作用：确保副作用在 commit 阶段执行，并按照依赖项优化更新

**数据结构**

```jsx
const effect = {
  tag: HookHasEffect,  // 是否需要执行
  create: effectFn,    // 副作用函数
  destroy: cleanupFn,  // 清理函数
  deps: [dep1, dep2],  // 依赖数组
  next: null,          // 链表结构
};
```

在 commit 阶段遍历 effectList，依次执行 useEffect 回调

## passiveEffectQueue(非同步副作用队列)

- 存储 useEffect 回调，确保在 commit 之后执行
- 作用：确保 useEffect 在 DOM 更新后异步执行，避免影响 UI 渲染

**数据结构**

```jsx
const passiveEffectQueue = [effect1, effect2, effect3];
```

通过 passiveEffectQueue 批量执行 useEffect，提高性能

## workInProgress tree(工作 Fiber 树)

- 存储正在计算的 fiber 阶段，用于双缓存渲染
- 作用：创建新的 Fiber 树，避免直接修改 current 树，提升渲染性能

**数据结构**

```jsx
const fiber = {
  type: FunctionComponent,  // 组件类型
  stateNode: component,     // 组件实例
  memoizedState: state,     // 组件的 state
  pendingProps: props,      // 组件的 props
  child: firstChild,        // 指向子 Fiber
  sibling: nextSibling,     // 指向兄弟 Fiber
  return: parentFiber,      // 指向父 Fiber
};
```

react 先在 workInProgress 树上计算更新，commit 阶段再同步到current树

- 调度层
- 渲染层
- 副作用管理
- fiber树

## 优先级 lane 模型

**源码位置：**

- fiber 优先级：[packages/scheduler/src/SchedulerPriorities.js](https://github.com/facebook/react/blob/v18.2.0/packages/scheduler/src/SchedulerPriorities.js)
- 优先级等级： [/react-reconciler/src/ReactFiberLane.js](https://github.com/facebook/react/blob/v19.0.0/packages/react-reconciler/src/ReactFiberLane.js)

介绍

- react 17 引入 lanes，优化调度任务
- 支持并发模式
- 高优先级支持

```jsx
export const NoPriority = 0;              // 没有优先级（默认值，表示任务未被调度）
export const ImmediatePriority = 1;       // 最高优先级（同步执行，不可中断）
export const UserBlockingPriority = 2;    // 用户交互（如输入框输入，几乎同步）
export const NormalPriority = 3;          // 正常优先级（大多数任务，如 `setState`）
export const LowPriority = 4;             // 低优先级（如数据预加载、非关键更新）
export const IdlePriority = 5;            // 最低优先级（后台任务、日志等，空闲时执行）
```

## 其他

- react fiber 的 Flags 标志位系统，用于标记各种状态和副作用，在 Reconciliation/render 和 commit 阶段影响 fiber 树的更新
    - [/react-reconciler/src/ReactFiberFlags.js](https://github.com/facebook/react/blob/v19.0.0/packages/react-reconciler/src/ReactFiberFlags.js)
    - **Placement**：**该 Fiber 是新插入的**，需要在 DOM 中创建新节点。
    - **Update**：**该 Fiber 发生了更新**，需要修改 DOM。
    - **ChildDeletion**：**需要删除子节点**，React 在提交阶段会遍历该 Fiber 进行删除。

### lane 模型

源码位置：[react-reconciler/src/ReactFiberLane.old.js](https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberLane.old.js)

React 中的 Lane 模型是用于管理任务优先级和调度的核心机制，实现了细粒度的任务控制。

### **1. Lane 的底层：31位掩码的暴力美学**

React 用 **31位二进制数** 表示不同的优先级（源码位置：[ReactFiberLane.old.js#L74](https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberLane.old.js#L74)）：

```jsx
export const TotalLanes = 31; // 最多支持31个优先级通道

// 每个 Lane 对应一个二进制位
export const SyncLane: Lane = 0b0000000000000000000000000000001;
export const InputContinuousHydrationLane: Lane = 0b0000000000000000000000000000010;
export const InputContinuousLane: Lane = 0b0000000000000000000000000000100;
// ... 中间省略其他 Lane ...
export const OffscreenLane: Lane = 0b1000000000000000000000000000000;
```

**为什么是31位？**

JavaScript 中 `number` 类型是64位双精度浮点数，但位运算（如 `|`, `&`）会被转换为 **32位有符号整数**。React 保留最高位（第32位）用于特殊处理，实际使用31位。

---

### **2. 核心操作：用位运算玩转优先级**

### **(1) 合并多个更新任务**

```jsx
// 合并两个Lanes集合（源码中的 mergeLanes）
const mergedLanes = laneA | laneB;
```

比如 `0b0001 | 0b0010 = 0b0011`，表示同时存在两个任务。

### **(2) 提取最高优先级任务**

React 源码中的操作（[getHighestPriorityLane](https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberLane.old.js#L445)）：

```jsx
function getHighestPriorityLane(lanes) {
  return lanes & -lanes; // 负数的二进制是补码表示
}
```

**为什么 `lanes & -lanes` 能得到最高优先级？**

假设 `lanes = 0b01010`（二进制），它的负数 `-lanes` 在二进制中是补码形式。按位与操作会保留最低位的1。例如：

```
0b01010 & -0b01010 → 0b00010
```

### **(3) 判断任务是否被中断**

源码中的 `includesSomeLane`：

```jsx
function includesSomeLane(a, b) {
  return (a & b) !== 0;
}
```

检查两个Lanes是否有交集，判断是否有更高优先级的任务插入。

---

### **3. 调度器如何选择执行哪个任务？**

关键函数：[getNextLanes](https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberLane.old.js#L586)

React 会从当前所有待处理的 Lanes 中，选出 **最高优先级且未被批处理** 的任务。

```jsx
function getNextLanes(root, workInProgressLanes) {
  // 1. 获取所有未被挂起的Lanes
  const pendingLanes = root.pendingLanes;

  // 2. 如果没有待处理任务，直接返回
  if (pendingLanes === NoLanes) return NoLanes;

  // 3. 获取最高优先级的Lane
  const nextLanes = getHighestPriorityLanes(pendingLanes);

  // 4. 检查是否应该批量处理（如事件回调中的多个setState）
  if (shouldBatchRender(root, nextLanes)) {
    return nextLanes | BatchedLane; // 合并批处理标记
  }

  return nextLanes;
}
```

---

### **4. 任务饥饿问题：低优先级任务被饿死怎么办？**

React 用 `expirationTimes` 记录每个 Lane 的过期时间（[源码](https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberLane.old.js#L827)）：

```jsx
// 为每个Lane计算过期时间
const expirationTimes = new Array(TotalLanes).fill(NoTimestamp);

function markStarvedLanesAsExpired(root, currentTime) {
  const pendingLanes = root.pendingLanes;
  const suspendedLanes = root.suspendedLanes;
  const pingedLanes = root.pingedLanes;

  let lanes = pendingLanes;
  while (lanes > 0) {
    // 找到当前最低位的lane
    const index = pickArbitraryLaneIndex(lanes);
    const lane = 1 << index;

    // 如果任务未过期，跳过
    const expirationTime = expirationTimes[index];
    if (expirationTime === NoTimestamp) {
      // 初始化过期时间（当前时间 + 优先级对应timeout）
      expirationTimes[index] = computeExpirationTime(lane, currentTime);
    } else if (expirationTime <= currentTime) {
      // 过期了！提升到同步优先级强制执行
      root.expiredLanes |= lane;
    }

    lanes &= ~lane; // 移除已处理的lane
  }
}
```

**关键点**：长时间未执行的低优先级任务会被提升为同步任务（`SyncLane`）强制执行，防止饿死。

---

### **5. 真实案例：点击事件中的高优先级中断**

假设一个场景：

- 正在渲染一个低优先级任务（`DefaultLane`）
- 用户突然点击按钮（触发 `InputContinuousLane`）

**React 内部发生了什么？**

1. **中断当前渲染**：通过 `prepareFreshStack` 重置工作栈
2. **合并Lanes**：`pendingLanes |= InputContinuousLane`
3. **重新调度**：由于 `InputContinuousLane` 优先级高于 `DefaultLane`，调度器立即处理点击事件
4. **执行高优任务**：完成点击事件对应的更新
5. **恢复低优任务**：如果有剩余时间，继续处理 `DefaultLane`

---

### **6. 调试技巧：在 DevTools 中查看当前Lanes**

React DevTools 的 **⚛️ Components** 面板中，选中组件后查看 `_reactInternals` 属性：

```
fiber.lanes;      // 当前渲染的Lanes
fiber.childLanes; // 子组件的Lanes
```

---

### **7. 性能优化：避免不必要的Lane冲突**

**反模式**：在低优先级任务中频繁触发高优先级更新（如动画中疯狂setState）

```jsx
// ❌ 在useEffect（DefaultLane）中连续触发高优先级更新
useEffect(() => {
  setInterval(() => {
    setState(prev => prev + 1); // 这些更新会使用DefaultLane
  }, 16);
}, []);
```

**优化方案**：

- 使用 `useLayoutEffect` 或 `flushSync` 提升优先级（谨慎使用！）
- 合并更新：用批量更新减少渲染次数

```jsx
// ✅ 合并更新
const [count, setCount] = useState(0);

const handleClick = () => {
  flushSync(() => {
    setCount(1); // SyncLane
    setCount(2); // 会被合并
  });
};
```

---

### **总结**

Lane 模型的本质是 **用位运算管理优先级**，React 通过31位的二进制掩码实现：

- **快速合并任务** → 按位或 (`|`)
- **提取最高优先级** → 位与补码 (`& -lanes`)
- **饥饿解决方案** → 过期时间提升优先级
- **并发渲染基础** → 可中断的任务调度

下次看源码时，直接搜索 `getHighestPriorityLane` 或 `mergeLanes`，看它们如何被调度器调用，就能抓住整个优先级调度的核心逻辑！