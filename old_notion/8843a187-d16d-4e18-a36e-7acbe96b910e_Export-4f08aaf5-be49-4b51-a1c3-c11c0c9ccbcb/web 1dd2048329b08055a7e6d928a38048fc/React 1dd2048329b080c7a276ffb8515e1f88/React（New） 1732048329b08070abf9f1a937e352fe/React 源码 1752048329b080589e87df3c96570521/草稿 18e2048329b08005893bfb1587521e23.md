# 草稿

### **前置知识储备**

- **Fiber 架构基础**：React 16+ 的核心架构，理解[Fiber 的设计动机](https://github.com/acdlite/react-fiber-architecture)（协程、可中断渲染、优先级调度等）。
- **虚拟 DOM 和协调算法**：熟悉 React 的 diffing 算法（Reconciliation）和双缓冲机制。
- **事件循环与任务调度**：了解 React 如何利用 `requestIdleCallback` 或 `scheduler` 包实现任务调度。
- **基础术语**：如 `FiberNode`、`UpdateQueue`、`Lanes`（优先级车道）、`Hooks` 等。

### **避坑指南**

- **不要直接硬啃**：先理解整体架构，再深入细节。
- **关注核心模块**：
    - `ReactFiberReconciler.js`（协调入口）
    - `ReactFiberWorkLoop.js`（工作循环）
    - `ReactFiberHooks.js`（Hooks 实现）
- **结合实践**：通过实现玩具级 React（如简易 Fiber 渲染）加深理解。

**createUpdate 生成的数据结构**

是一个链式结构

**作用**

- 生成一个 **update**（更新对象），用于存储组件的状态变更信息。
- 这些 update 会被 **enqueueUpdate** 加入组件对应的 fiber.updateQueue，然后 React 通过调度机制处理它们。
- 组件调用 `setState` 时触发，这个机制确保 批量更新和避免不必要的重新渲染。

```jsx
{
  eventTime: eventTime,  // 记录更新发生的时间
  lane: lane,            // 表示更新的优先级
  tag: UpdateState,      // 标识更新的类型
  payload: null,         // 存储新的 state 数据/可能是对象，可能是函数
  callback: null,        // 更新完成后的回调函数
  next: null             // 指向下一个更新，形成更新链表
}
```

**eventTime**

- 表示该更新发生的时间戳，通常是 performance.now() 获取的时间。
- React 使用 eventTime 来帮助调度更新，确保高优先级任务（如用户输入）能更快执行，而低优先级任务（如数据加载）可以延后处理。

**lane**

- 代表该更新的优先级。React 18 引入了 **调度 lanes**（类似于任务队列的概念），不同的 lane 代表不同优先级的任务。例如：
- **SyncLane**（同步更新）—— 最高优先级，如用户交互事件。
- **TransitionLane**（过渡更新）—— 如 startTransition 触发的状态更新，低优先级。
- **IdleLane**（空闲更新）—— 最低优先级，仅在浏览器空闲时执行。

**tag**

- 用于标识更新的类型，通常有：
- UpdateState（常规 state 更新，setState 触发的更新）
- ReplaceState（替换整个 state）
- ForceUpdate（强制更新，不依赖 state 变化）
- CaptureUpdate（捕获错误更新）

**payload**

- 该字段存储 **新的 state 数据**，在 setState 发生时，payload 会被填充：

**callback**

- 如果 setState 传入了回调函数，那么 callback 就会指向这个回调函数，在更新完成后执行。

**next**

- next 指向 **下一个 update**，React 采用 **链表结构** 来存储更新，多个 setState 可能会形成一个更新队列。

## 是不是先了解一下调度 scheduler

好像很简单的样子，也就是堆结构，然后一些堆方法。。

- 我需要记住数据结构
- 以及api的细节
- 在 react 中起到的关键作用

**Scheduler 调度任务**：

•	任务入 taskQueue（MinHeap）。

•	取出 expirationTime 最小的任务执行。

•	执行 performConcurrentWorkOnRoot() 进入 Fiber 协调（Reconciliation）。