# 核心算法

## update 对象

是一个链表

[图片参考](%E6%A0%B8%E5%BF%83%E7%AE%97%E6%B3%95%201942048329b0804fbcfdc8b64a7bbee9.md)

```jsx
function createUpdate(eventTime, lane) {
  var update = {
    eventTime: eventTime,
    lane: lane,
    tag: UpdateState,
    payload: null,
    callback: null,
    next: null
  };
  return update;
}

  var update = createUpdate(eventTime, lane); // Caution: React DevTools currently depends on this property
  // being called "element".

  update.payload = {
    element: element
  };
  callback = callback === undefined ? null : callback;

UpdateQueue

baseState: 表示此队列的基础 state
firstBaseUpdate: 指向基础队列的队首
lastBaseUpdate: 指向基础队列的队尾
shared: 共享队列
effects: 用于保存有callback回调函数的 update 对象, 在commit之后, 会依次调用这里的回调函数.
SharedQueue

pending: 指向即将输入的update队列. 在class组件中调用setState()之后, 会将新的 update 对象添加到这个队列中来.
Update

eventTime: 发起update事件的时间(17.0.2 中作为临时字段, 即将移出)
lane: update所属的优先级
tag: 表示update种类, 共 4 种. UpdateState,ReplaceState,ForceUpdate,CaptureUpdate
payload: 载荷, update对象真正需要更新的数据, 可以设置成一个回调函数或者对象.
callback: 回调函数. commit完成之后会调用.
next: 指向链表中的下一个, 由于UpdateQueue是一个环形链表, 最后一个update.next指向第一个update对象.
```

## Hook 对象

它也是一个链表

```jsx
Hook
memoizedState: 内存状态, 用于输出成最终的fiber树
baseState: 基础状态, 当Hook.queue更新过后, baseState也会更新.
baseQueue: 基础状态队列, 在reconciler阶段会辅助状态合并.
queue: 指向一个Update队列
next: 指向该function组件的下一个Hook对象, 使得多个Hook之间也构成了一个链表.
Hook.queue和 Hook.baseQueue(即UpdateQueue和Update）是为了保证Hook对象能够顺利更新, 与上文fiber.updateQueue中的UpdateQueue和Update是不一样的(且它们在不同的文件), 其逻辑会在状态组件(class 与 function)章节中详细解读.
```

## Task 对象

最小堆

```jsx
var newTask = {
  id: taskIdCounter++,
  callback,
  priorityLevel,
  startTime,
  expirationTime,
  sortIndex: -1,
};

id: 唯一标识
callback: task 最核心的字段, 指向react-reconciler包所提供的回调函数.
priorityLevel: 优先级
startTime: 一个时间戳,代表 task 的开始时间(创建时间 + 延时时间).
expirationTime: 过期时间.
sortIndex: 控制 task 在队列中的次序, 值越小的越靠前.
```

## Fiber 对象？？？

- fiberRoot.current =  HostRootFiber
- HostRootFiber.stateNode = fiberRoot

### **memoizedState**

```jsx
**memoizedState**

	  var cache = {
    controller: new AbortControllerLocal(),
    data: new Map(),
    refCount: 0
  };
    var initialState = {
      element: initialChildren,
      isDehydrated: hydrate,
      cache: initialCache,
      transitions: null,
      pendingSuspenseBoundaries: null
    };
    **uninitializedFiber.memoizedState = initialState;**
```

### updateQueue

```jsx
function initializeUpdateQueue(fiber) {
  var queue = {
    baseState: fiber.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: {
      pending: null,
      interleaved: null,
      lanes: NoLanes
    },
    effects: null
  };
  **fiber.updateQueue = queue;**
}
```

## Task

```jsx
  var newTask = {
    id: taskIdCounter++,
    callback: callback,
    priorityLevel: priorityLevel,
    startTime: startTime,
    expirationTime: expirationTime,
    sortIndex: -1
  };
**push(timerQueue, newTask); // newTask === newCallbackNode
root.callbackNode = newCallbackNode;**

```