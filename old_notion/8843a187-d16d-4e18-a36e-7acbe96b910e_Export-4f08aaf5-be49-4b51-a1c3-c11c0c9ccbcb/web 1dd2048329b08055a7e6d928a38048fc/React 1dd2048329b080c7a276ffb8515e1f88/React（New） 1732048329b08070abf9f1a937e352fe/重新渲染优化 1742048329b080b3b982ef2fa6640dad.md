# 重新渲染优化

## 参考

- [你需要 memo 吗](https://overreacted.io/before-you-memo/)

## useMemo

- 大量计算
- 保留引用 → 针对 `React.memo()`

## useCallback

- 保留引用

## 引用

当封装通用 hook 时，因为不知道要用在什么地方，可以提前保留引用，避免重新渲染

```tsx
~~function~~ useToggle(initialValue) {
  const [value, setValue] = React.useState(initialValue);

  const toggle = React.useCallback(() => {
    setValue(v => !v);
  }, []);

  return [value, toggle];
}
```

上下用优化

```tsx
const AuthContext = React.createContext({});

function AuthProvider({ user, status, forgotPwLink, children }){
  const memoizedValue = React.useMemo(() => {
    return {
      user,
      status,
      forgotPwLink,
    };
  }, [user, status, forgotPwLink]);

  return (
    <AuthContext.Provider value={memoizedValue}>
      {children}
    </AuthContext.Provider>
  );
}
```

## 你真的需要 memo 吗？

当然是有一些技巧可以替代 `memo` 或 `useMemo`

### 状态下移

当组件内只有一部分关心状态变化时，可以将状态下移至另一个子组件，避免触发父组件的重新渲染

- 将受状态影响的元素抽离为子组件

```tsx
export default function App() {
  let [color, setColor] = useState('red');
  return (
    <div>
      <input value={color} onChange={(e) => setColor(e.target.value)} />
      <p style={{ color }}>Hello, world!</p>
      <ExpensiveTree />
    </div>
  );
}
// 状态下移后
export default function App() {
  return (
    <>
      <Form />
      <ExpensiveTree />
    </>
  );
}
 
function Form() {
  let [color, setColor] = useState('red');
  return (
    <>
      <input value={color} onChange={(e) => setColor(e.target.value)} />
      <p style={{ color }}>Hello, world!</p>
    </>
  );
}
```

### 提升内容

将依赖状态的组件提升为接受 `children` 的组件包装起，同样可以避免父组件的重新渲染。

```tsx
export default function App() {
  return (
    <ColorPicker>
      <p>Hello, world!</p>
      <ExpensiveTree />
    </ColorPicker>
  );
}
 
function ColorPicker({ children }) {
  let [color, setColor] = useState("red");
  return (
    <div style={{ color }}>
      <input value={color} onChange={(e) => setColor(e.target.value)} />
      {children}
    </div>
  );
}

```