# Suspense

## use

**作用：**从已准备好的资源总读取数据，而不是创造数据

**规则：**

- 必须依赖外部缓存，确保数据加载发生在渲染阶段之外
- 如果数据未准备好，会抛出 Promise，由 Suspense 暂定渲染病处理加载状态
- **渲染阶段需要是纯函数，不应包含副作用**
- **如果没有缓存，每次渲染都会重新触发异步操作，导致无限循环（因为渲染本身会重复触发副作用）。**
- 至少需要缓存 promise

**典型场景：**与 Suspense 配合，用于异步数据加载

```tsx
// 缓存层：提前触发数据加载并存储
const dataCache = {
  data: null,
  promise: null,
  fetch(url) {
    if (!this.promise) {
      this.promise = fetch(url)
        .then(res => res.json())
        .then(data => this.data = data);
    }
    if (!this.data) throw this.promise; // 数据未准备好，抛出 Promise
    return this.data;                   // 数据已准备好，直接返回
  }
};

// 渲染阶段：只读取缓存
const resource = dataCache.fetch('/api/data'); // 不会重复发请求
const data = use(resource); // Suspense 将处理未完成的 Promise
```

## lazy

作用：动态加载组件，实现代码分割，减少初始加载体积

规则：

- 使用 `React.lazy(()=>import('./Component'))`
- 需要结合 Suspense 提供加载占位符

典型场景：对路由组件或次要功能组件进行懒加载

```tsx
const LazyComponent = React.lazy(() => import('./Component'));
<Suspense fallback={<div>Loading...</div>}>
  <LazyComponent />
</Suspense>
```

## 如何让 fetch 支持 Suspense

https://blog.logrocket.com/data-fetching-react-suspense/#what-react-suspense

当还没有 Suspense 时，我们是这样处理的

- 设置一个 `isLoading` 变量
- 请求开始时，变量为 `true` 时，组件返回正在加载的状态组件
- 请求结束时，变量值为 `false` 返回另一个组件，这个组件就是渲染加载数据后的美容。

```tsx
const [todos, isLoading] = fetchData('/todos')

if (isLoading) {
  return <Spinner />
}

return <Todos data={todos} />
```

wrapPromise

- 还是使用 react-query 这样现成的库吧，面试好像也不问这个

```tsx
function wrapPromise<T>(promise: Promise<T>): () => T {
    let status = 'pending'
    let response: T
    const suspender = promise.then(
        (res) => {
            status = 'success'
            response = res
        },
        (err) => {
            status = 'error'
            response = err
        },
    )
    return () => {
        switch (status) {
            case 'pending':
                throw suspender
            case 'error':
                throw response
            default:
                return response
        }
    }
}

function createSupplier(dataId: number) : () => Data {
    const data: Promise<Data> = fetchData(dataId) // External API
    return wrapPromise<Data>(data)
}

```