# useState

## React 的思维

React 是一个用于构建用户界面的库，其核心思想是：

1. **声明式编程**：描述你希望 UI 的样子，React 会负责更新和渲染组件。
2. **组件化**：将 UI 分解成独立的、可复用的组件。
3. **状态驱动**：组件的渲染由状态（state）和属性（props）驱动。
4. **不可变性**：React 的状态更新倾向于不可变性以简化变更追踪，保证数据的一致性。

## useState 定义

useState 是 React 中的一个 **Hook**，用于在函数组件中引入状态管理。

**定义**

```tsx
const [state, setState] = useState(initialState);
```

**参数**

- `initialState`
    - 状态的初始值
    - 可以是任意类型，也可以是一个函数（懒初始化）

**返回值**

- 一个数组 `[state,setState]`
    - `state` 当前状态值
    - `setState` 更新状态的函数**（异步操作）**

## 核心思想

React 的状态管理基于一个**统一的更新队列**和**Fiber 树**。在每个渲染周期中，React 会：

1. **保存一个状态的“快照”**（当前渲染使用的状态）。
2. **通过更新队列收集所有状态更新操作**。
3. **在一个合适的时机批量应用更新**，生成新的状态快照，并触发组件重新渲染。

因此：

- **快照机制**：确保每次渲染中使用的是一致的状态值。
- **批量更新**：通过延迟和合并状态更新，避免多次不必要的渲染。

> TODO: 还是需要结合源码/源码中原理的总结来看。
> 

## 快照机制&批量更新

**快照**

1. React 的状态是基于“快照”更新
2. 在某个渲染周期中，state 的值是固定的，即使调用了 setState，该值也不会在同一渲染中改变
3. 每次调用 setState，会触发一个新的渲染周期，React 会使用最新的状态值

**批量更新**

1. 批量更新的目的是优化性能，避免在一次事件循环中触发多次重新渲染
2. React 会收集所有的 setState 调用，并在**事件结束后**合并这些更新，一次性重新渲染。

**快照机制+批量更新**

```tsx
function Counter() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    setCount(count + 1);
    setCount(count + 2); // 同一事件中两次更新
    console.log(count); // 快照值
  };

  return <button onClick={handleClick}>增加</button>;
}
```

- setCount(count + 1) 和 setCount(count + 2) 的更新会被批量合并，最后只渲染一次。
- count 的最终值是 2（取最后一次更新结果）。

**函数式更新**

```tsx
function Counter() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    setCount(prevCount => prevCount + 1);
    setCount(prevCount => prevCount + 2); // 使用函数式更新
    console.log(count); // 快照值
  };

  return <button onClick={handleClick}>增加</button>;
}
```

- 通过函数式更新，setState 不再依赖于当前渲染周期的 state 快照。
- React 内部会合并这两个更新，按顺序应用到最新的状态。
- 如果函数式更新有普通的更新，则取最后一次普通跟心的最结果

## 总结

- 快照机制：确保了状态的一致性，是状态在当前渲染周期中不会动态变化
- 批量更新：优化了性能，避免了不必要的渲染

## 常见问题解答

1. 为什么 state 不立即更新？
    
    React 会优化渲染过程， setState 是异步的，目的是减少不必要的重新渲染
    
2. 如何调试最新状态？
    
    使用 `useEffect` + `console.log` 或者 `React Developer Tools` 观察状态变化
    
3. `useState` 与 `useReducer` 的区别
    - `useState` 适合简单的状态管理
    - `useReducer` 适合复杂状态逻辑操作