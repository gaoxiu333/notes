# 函数式编程术语

来源：https://github.com/shfshanyue/fp-jargon-zh

以下的概念解释起来，其实都是通过函数调用来生成一个新的函数（调用时会通过参数来定制化），并不是通过简单的声明式来声明一个函数的。

## 闭包

在 JavaScript中，闭包是通过一个函数返回另外一个函数，返回的这个函数可以访问外部函数作用域中的变量，从而形成闭包。

**作用：**闭包就是一个函数记住了它定义时所在的环境变量，即使这个环境已经消失，他仍然能够访问

**消除闭包：**删除闭包函数的引用，将返回的这个函数等于 `null` 皆可。

## 偏函数

偏函数就是先给一个函数填充好一部分参数，锁定它的部分功能，得到一个定制版的新函数，新函数接受后续的参数。

## 柯里化

定义：把多元函数转换成一元函数的过程。

柯里化就是把一个需要多个参数的函数，拆成每次只接受一个参数的函数链，并且每次返回一个新函数，直到所有参数都传递完毕时才返回最终结果。

## 自动柯里化

TODO：面试题里边有

## 纯函数

输出仅由输入决定，不产生副作用

## 副作用

如果一个函数或者表达式除了返回一个值之外，它还与外部可变状态进行交互（读取/写入），那么它是有副作用的。

## Lambda

一种可以被视作一个值的匿名函数

- 通常作为参数传递给高阶函数
- 或者作为值赋值给一个变量

## 惰性求值

按需调用的求值机制，定义时不计算，使用时才计算

```tsx
const rand = function*(){
	while (true){
		yield Math.random()
	}
}
const randIter = rand()
randIter.next()
```

使用闭包来实现惰性求值

```tsx
function lazyCompute() {
    console.log("Performing calculation...");
    return 42;
}

const result = () => lazyCompute(); // 定义时不计算
console.log("Before using result...");
console.log(result()); // 此时才输出 "Performing calculation..." 和 42
```

## 同构

两个不同类型的对象之间的变换，保持结构并且不丢失数据

todo: 加一个可以折叠的例子

防抖

节流