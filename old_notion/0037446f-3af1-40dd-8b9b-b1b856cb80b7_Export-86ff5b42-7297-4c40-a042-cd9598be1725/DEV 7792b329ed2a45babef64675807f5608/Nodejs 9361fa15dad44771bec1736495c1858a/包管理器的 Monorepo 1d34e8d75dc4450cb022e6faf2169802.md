# 包管理器的 Monorepo

Owner: xiu gao

# 包管理器的 Monorepo

## 前言

1. 什么时候需要monorepo？
    
    当你管理多个功能相近，又相互依赖的包时，如果把这些包拆分到不同仓库里，那么将面临跨多个包更改和调试。
    
2. monorepo有哪些优劣？
    
    优：一个仓库里维护多个package，可以统一构建，跨package调试，依赖管理，版本发布等
    
    劣：代码仓库体积变大，开发其中一个package也需要安装整个项目依赖
    

## 使用pnpm创建monorepo

与yarn工作空间相比，PNPM工作空间的主要优点是公共包不会提升到根目录，从而使所有工作空间包完全隔离。

### 使用堆栈/功能

- pnpm
- typescript

### 主项目初始化

```
mkdir pnpm-monorepo
cd pnpm-monorepo
pnpm init
git init # 如果有必要
echo -e 'node_modules' > .gitignore
npm pkg set engines.node='>=18'
npm pkg set type='module'
echo '#pnpm monorepo' > README.md
```

### workspace 配置

- 创建`pnpm-workspace.yaml`并添加一下内容

```yaml
packages:  - 'apps/*'  - 'packages/*'
```

- 在根目录创建`apps`和`packages`文件夹

```
mkdir apps packages
```

### 初始化子项目

创建`lib`包和`web-app`应用程序。

```
cd packages
pnpm create vite lib --template vanilla-ts

cd apps
pnpm create vite web-app --template react-ts

cd 根目录
pnpm install
npm pkg set scripts.lib='pnpm --filter lib'
npm pkg set scripts.darftapp='pnpm --filter draft-app'
```

### 启动项目

```
# 启动 web-app
pnpm web dev

# 启动 lib
pnpm lib dev
```

## 相互依赖示例

比如`web-app`依赖`lib`中的`counter`方法。

### Library 模式配置

Vite默认以app模式构建资源，以index.html为入口文件。需要改动将 main.ts 文件公开为入口文件，更新 Vite 配置以支持这一点。

- `vite-plugin-dts` - 自动生成类型定义
    
    ```
    pnpm lib add vite-plugin-dts -D
    # or
    cd ./packages/lib
    pnpm add vite-plugin-dts -D
    ```
    
- 修改`vite.config.ts`,没有配置文件就创建一个。
    
    ```tsx
    import { defineConfig } from 'vite'import { resolve } from 'path'import dts from 'vite-plugin-dts'// https://vitejs.dev/config/export default defineConfig({
        build: { lib: { entry: resolve(__dirname, 'src/main.ts'), formats: ['es'] } },    resolve: { alias: { src: resolve('src/') } },    plugins: [dts()],})
    ```
    
    使用`path.resolve`将路径解析为绝对路径，以避免vite解析系统路径别名问题。
    
    参考Vite官方文档：[resolve.alias](https://cn.vitejs.dev/config/shared-options.html#resolve-alias)
    > TODO：消除config报错要安装`@type/node`么？还说说一定要配置`typs:commonjs`?
    
- 更新`package.json`指定入口文件
    
    ```json
      "main": "./dist/main",  "types": "./dist/main.d.ts",
    ```
    

### 项目依赖

- 更新`web-app`项目的`package.json`文件
    
    ```json
      "dependencies": {    "lib":"workspace:*",    // ...  },
    ```
    
- 再次运行`pnpm install`，以便`web-app`可以链接到工作区中存在的`lib`包
- 执行`pnpm lib build`，以便`web-app`可以找到这个包
- 在`web-app`中引用和使用
    
    ```jsx
    import { useState } from 'react'import { counter } from 'lib'function App() {
      const [count, setCount] = useState(0)
      return (
        <>      <button onClick={() => setCount(counter(count, 1))}>count:{count}</button>    </>  )
    }
    export default App
    ```
    

### 开发环境配置

- 大多数时候，您只需要构建`common`一次包并在存储库应用程序中使用它。但是，如果您正在积极地对`common`包进行更改，并希望立即在“网络应用程序”中看到它，则您无法`common`为每次更改一次又一次地构建应用程序。

为了避免这种情况，让我们`common`在监视模式下运行该包，以便代码中的任何更改都将自动重建并实时反映在“网络应用程序”中。

```
pnpm common build --watch
pnpm web-app dev
```

### 优点：

- 您的所有代码都将位于一个具有适当隔离的存储库中。
- 只需一次性的工作就可以通过正确的 linting、格式设置和预提交挂钩验证来设置存储库，这些验证将由工作区包扩展。
- 所有软件包都将具有相似的设置、外观和感觉。

## 参考

https://dev.to/vinomanick/create-a-monorepo-using-pnpm-workspace-1ebn

- [npm-workspaces](https://link.juejin.cn/?target=https%3A%2F%2Fdocs.npmjs.com%2Fcli%2Fusing-npm%2Fworkspaces)
- [yarn-workspaces](https://link.juejin.cn/?target=https%3A%2F%2Fyarnpkg.com%2Ffeatures%2Fworkspaces)
- [pnpm-workspaces](https://link.juejin.cn/?target=https%3A%2F%2Fpnpm.io%2Fworkspaces)
- [Monorepo Explained](https://link.juejin.cn/?target=https%3A%2F%2Fmonorepo.tools)
- [Vite 库模式](https://cn.vitejs.dev/guide/build#library-mode)