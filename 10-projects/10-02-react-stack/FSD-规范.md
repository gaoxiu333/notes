## Feature-Sliced Design (FSD) 规范总结

Feature-Sliced Design (FSD) 是一种用于搭建前端应用程序的架构方法论。它本质上是一系列关于如何组织代码的规则和约定，其主要目的是在不断变化的业务需求面前，让项目更易于理解、更结构化且更稳定。

### 核心结构：层、切片与段

FSD 的组织结构包含三个主要层级：层 (Layers)、切片 (Slices) 和段 (Segments)。

#### 1. 层 (Layers)
层是 FSD 中的第一级组织结构，旨在根据代码所需承担的职责以及其在应用中依赖其他模块的程度来分离代码。FSD 共定义了7个层，按职责和依赖从高到低排列：

* **App (应用层)**：负责应用的初始化、路由配置、全局上下文提供者、全局样式等。
* **Processes (流程层)** (已弃用)：原用于处理复杂的跨页面交互场景。目前建议将其内容移至 features 和 app 层。
* **Pages (页面层)**：代表应用中的完整页面或嵌套路由中的大型界面部分。一个页面通常对应一个切片。
* **Widgets (小组件层)**：大型、独立的、通常可跨多个页面复用的UI功能块，能够提供完整的使用场景。
* **Features (功能层)**：封装了用户与产品交互的具体功能点，即那些为用户带来业务价值的操作。一个好的判断标准是该功能是否在多个页面被复用。
* **Entities (实体层)**：代表项目所处理的核心业务领域概念，通常是业务人员描述产品时使用的术语，例如用户 (User)、帖子 (Post)。
* **Shared (共享层)**：作为应用其余部分的基础，用于提供与外部世界（如后端、第三方库、环境）的连接，或定义高度内聚的内部库。此层不包含业务逻辑。

**层的导入规则**：一个切片中的模块（文件）只能导入严格位于其下方层级的其他切片。App 层和 Shared 层是此规则的例外，它们本身可以看作是一个特殊的切片，其内部的段可以自由相互导入。

#### 2. 切片 (Slices)
切片是 FSD 中的第二级组织结构，其主要目的是根据代码对于产品、业务或应用的含义来进行分组。切片的名称并非标准化，而是由应用的具体业务领域直接决定。

* **高内聚低耦合**：切片旨在成为独立且高度内聚的代码文件组。其独立性通过层的导入规则来保障。
* **公共 API 规则**：每个切片（以及没有切片的层中的段）都必须包含一个公共 API 定义。切片外部的模块只能引用其公共 API，而不能直接访问切片内部的文件结构。
* App 层和 Shared 层不包含切片。

#### 3. 段 (Segments)
切片以及 App 层和 Shared 层都由段组成，段会根据其技术性质对代码进行分组。段名称不受标准约束，但针对最常见的用途，有几种约定俗成的名称：

* `ui`— 与 UI 显示相关的一切：UI 组件、日期格式化程序、样式等。
* `api`— 后端交互：请求函数、数据类型、映射器 (mappers) 等。
* `model`— 数据模型：模式 (schemas)、接口、状态存储 (stores) 和业务逻辑。
* `lib`— 此切片上的其他模块所需的库代码或辅助函数。
* `config`— 配置文件和功能标志 (feature flags)。

段的名称应描述其内容的目的，而非其本质（例如，避免使用 `components`、`hooks`、`types` 等作为段名）。

### 关键原则

* **公共 API (Public API)**：是切片/段与其使用者之间的契约，通常通过索引文件（如 `index.js`）重新导出模块来实现。一个好的公共 API 应保护应用其他部分免受切片内部结构变化的影响，并仅暴露必要的部分。
    * **交叉导入的公共 API (`@x` 表示法)**：当实体层中的不同实体间存在合理的交叉引用需求时，可以使用 `@x` 表示法为目标实体声明一个特殊的公共 API，例如 `entities/A/@x/B.ts` 允许 `entities/B/` 中的代码导入 `entities/A` 中的特定内容。建议仅在实体层谨慎使用此表示法。
* **命名规范 (Naming)**：FSD 对层和段采用特定的术语和约定名称，这对于团队成员间的沟通和新开发者的理解至关重要。使用标准名称也有助于从社区获取帮助。
* **需求驱动 (Needs Driven)**：为了给实体及其组件选择清晰的名称，并理解其构成，需要清晰地理解所有这些代码将解决什么任务。FSD 强调通过理解用户需求和业务价值来驱动功能和实体的分解。

### 优势

* **统一性 (Uniformity)**：标准化的结构使得项目更加统一，有助于新成员更快地熟悉项目。
* **变更与重构的稳定性 (Stability in face of changes and refactoring)**：由于层与层之间的导入限制，可以在不产生意外副作用的情况下进行隔离修改。
* **受控的逻辑复用 (Controlled reuse of logic)**：根据代码所在的层级，可以实现高度复用或高度本地化，在DRY原则和实用性之间取得平衡。
* **面向业务与用户需求 (Orientation to business and users needs)**：应用按业务领域划分，鼓励在命名中使用业务术语，使开发者无需完全理解项目所有其他不相关的部分即可进行有效的产品开发。

### FSD 的目标与动机

FSD 旨在通过结合研究成果和广泛开发者的经验，促进和降低复杂且不断发展的项目的开发成本。它并非万能药，但致力于解决前端开发中的日常问题，例如：
* 现有设计原则（SOLID, KISS等）过于通用，不足以指导具体架构设计。
* 文档、测试和流程并不能完全解决架构问题和新人上手困难。
* 避免每个项目都形成“独一无二的雪花”，导致知识难以复用。
FSD 的目标是提供一个经过实战检验的方法，让开发者能更专注于业务功能，减少在架构问题上耗费的精力，并实现项目间的标准化。

### 适用性与迁移

FSD 适用于各种规模的前端项目，并且不限制使用的编程语言、UI 框架或状态管理器。它可以被增量采用。文档中提供了从自定义架构或旧版本 FSD 迁移的指南。同时，也包含了在特定技术栈（如 NextJS，NuxtJS，React Query，SvelteKit）中应用 FSD 的指导。

### 具体用例实践

FSD 文档提供了一系列实践案例和指南，例如：
* **认证 (Authentication)**：如何分解认证逻辑，包括表单、2FA、OAuth、Token 存储与刷新等。
* **类型处理 (Types)**：如何在 FSD 架构中管理类型，包括 DTO、映射器、实体关系、自动生成和校验模式等。
* **页面布局 (Page layouts)**：处理页面布局的常见情况，如存储位置和在布局中使用 Widgets。