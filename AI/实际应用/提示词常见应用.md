# 提示工程作为开发者学科

> 译自 [Prompt Engineering as a Developer Discipline](https://neon.tech/blog/prompt-engineering-developer-discipline)  
> 作者：Andrew Tate  
> 发布：2025/04/21

结构化提示是每个开发者都需要掌握的新编程技能

AI已经来临。这可能听起来是句老生常谈,但仍有近四分之一的开发者将AI视为他们不打算使用的东西。

但"使用AI"并不一定意味着要将你的应用程序完全交给AI来编码。作为开发者使用AI意味着两件事:

1. 理解AI是理想的结对编程伙伴
2. 理解如何最大限度地利用AI来创建你想要的代码

第二点的关键是有效的提示工程。与DRY、SOLID等编程原则和其他开发最佳实践一样,提示工程正在成为现代开发者工具包中的关键技能。从LLM获得优质代码始于优质提示。就像编写整洁的函数或类需要细心和结构一样,制作有效的提示也需要有条理的思维和精确性。

**提示并不是一个猜谜游戏——它是一门植根于逻辑、测试和结构的工艺。最成功的开发者用对待传统代码的同样严谨态度来对待提示:设计、改进和优化以获得清晰的输出。**

在这里,我们认为开发者应该将提示视为软件组件——模块化的、可测试的部分,可以被评估、迭代并集成到更大的系统中。从这个角度来看,提示工程成为一个系统化的学科,使开发者能够以一致性和信心来驾驭AI。

## 少样本和单样本提示:展示,而不仅仅是告诉

当你提供想要的输出示例时,你会增加获得格式正确、符合上下文的代码的可能性。这种方法利用了语言模型的模式匹配能力。

没有示例时:

> 编写一个计算斐波那契数列的函数。

输出:

```python
# 这是一个计算斐波那契数列的Python函数:
def fibonacci(n):
    fib_sequence = [0, 1]
    for i in range(2, n):
        next_number = fib_sequence[i-1] + fib_sequence[i-2]
        fib_sequence.append(next_number)
    return fib_sequence
# 使用示例
n = 10
result = fibonacci(n)
print(result)
```

有示例时:

```python
编写一个计算斐波那契数列的函数。

以下是我偏好的另一个函数风格示例:
def is_prime(n: int) -> bool:
    """
    判断一个数是否为质数。
    
    参数:
        n: 要检查的数
        
    返回:
        如果n是质数返回True,否则返回False
    """
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True
```

输出:

```python
def fibonacci(n: int) -> List[int]:
    """
    生成斐波那契数列直到第n个数。
    
    参数:
        n: 要生成的斐波那契数的数量
        
    返回:
        包含直到第n个数的斐波那契数列的列表
    """
    fib_sequence = []
    a, b = 0, 1
    for _ in range(n):
        fib_sequence.append(a)
        a, b = b, a + b
    return fib_sequence
```

有了示例,模型会模仿你偏好的文档风格和函数签名约定。它不会采用默认值,而是适应你提供的结构,产生更符合习惯且易于集成的代码。

## 思维链:引导逐步推理

通过提示AI逐步解决问题,你可以确保逻辑进展并在问题出现在代码中之前发现潜在问题。这种模式对于复杂算法或业务逻辑特别有价值。

没有推理时:

> 创建一个为整数数组实现快速排序的函数。

输出:

```python
好的!这是快速排序算法的Python实现:

def quicksort(arr):
    if len(arr) <= 1:
        return arr
    else:
        pivot = arr[0]
        less_than_pivot = [x for x in arr[1:] if x <= pivot]
        greater_than_pivot = [x for x in arr[1:] if x > pivot]
        return quicksort(less_than_pivot) + [pivot] + quicksort(greater_than_pivot)
# 使用示例
arr = [3, 6, 8, 10, 1, 2, 1]
sorted_arr = quicksort(arr)
print(sorted_arr)
```

有推理时:

> 创建一个为整数数组实现快速排序的函数。
> 
> 请:
> 首先解释快速排序算法及其时间复杂度
> 然后概述实现所需的关键组件
> 使用清晰、描述性的变量名编写函数
> 添加适当的错误处理
> 包含解释每个主要步骤的注释

输出:

```
### 快速排序算法:
- 快速排序是一种流行的排序算法,使用分治策略。
- 它通过从数组中选择一个基准元素,并根据其他元素是小于还是大于基准将它们分成两个子数组来工作。
- 然后对子数组递归重复这个过程。
- 快速排序的平均时间复杂度是O(n log n),但在最坏情况下可能退化为O(n²)。

### 实现的关键组件:
1. 选择基准元素(通常是数组中的最后一个元素)。
2. 围绕基准对数组进行分区,使得小于基准的元素在左边,大于的元素在右边。
3. 递归地将上述步骤应用于子数组。

### 函数实现:
```python
from typing import List
def quicksort(arr: List[int]) -> List[int]:
    """
    使用快速排序算法对整数数组进行排序。
    参数:
    arr (List[int]): 要排序的整数列表
    返回:
    List[int]: 排序后的整数列表
    """
    if len(arr) <= 1:
        return arr  # 基本情况:如果数组为空或只有一个元素,它已经排序好了
    pivot = arr[-1]  # 选择最后一个元素作为基准
    smaller, equal, larger = [], [], []
    for num in arr:
        if num < pivot:
            smaller.append(num)
        elif num == pivot:
            equal.append(num)
        else:
            larger.append(num)
    return quicksort(smaller) + equal + quicksort(larger)  # 递归排序子数组并连接
```

### 错误处理:
- 该函数处理输入数组为空或只有一个元素的情况,此时它只需返回数组本身,因为它已经排序好了。

## 自一致性:多重推理路径

对于特别复杂的问题,指导模型生成多个独立的解决方案然后选择最佳方案可以显著提高可靠性。这模仿了高级开发人员经常处理具有挑战性问题的方式。

### 组件库示例

以下是基于组件的提示系统在实践中的样子:

```javascript
// 角色
const personas = {
  backendExpert: `你是一位有15年以上经验的高级后端开发者,
                  专门从事分布式系统和API设计。你在所有代码中
                  都优先考虑可扩展性、安全性和可维护性。`,
  
  securitySpecialist: `你是一位网络安全专家,对应用程序安全、
                       威胁建模和安全编码实践有深入的了解。
                       你总是能识别代码中的潜在漏洞。`
};

// 输出格式
const formats = {
  json: `将你的响应作为有效的JSON对象返回,不要有任何额外的解释。`,
  
  markdown: `将你的响应格式化为markdown,使用适当的标题、
             带有语言标签的代码块,以及在相关处使用项目符号。`
};

// 任务模板
const tasks = {
  codeReview: `检查以下代码中的{aspect}问题:
               
               \`\`\`{language}
               {code}
               \`\`\`
               
               特别关注{focus_area}。`,
  
  implementation: `编写实现{feature}的{language}代码,
                   要求如下:
                   
                   {requirements}`
};

// 组合完整提示
function createPrompt(components) {
  return [
    components.persona,
    components.task,
    components.format
  ].join('\n\n');
}

// 使用示例
const securityReviewPrompt = createPrompt({
  persona: personas.securitySpecialist,
  task: tasks.codeReview
    .replace('{aspect}', 'security')
    .replace('{language}', 'python')
    .replace('{code}', userCode)
    .replace('{focus_area}', 'input validation and SQL injection'),
  format: formats.markdown
});
```

这种基于组件的方法带来了几个优势:

1. 一致性:标准化组件确保应用程序中输出的统一性
2. 可维护性:更新一次组件就能影响使用它的所有提示
3. 版本控制:像跟踪任何其他代码一样跟踪提示组件的变化
4. 协作:团队可以在项目间共享和重用组件
5. 测试:验证单个组件的可靠性
6. 文档:自文档化的提示架构

## 提示检查:在执行前验证结构

就像开发者依赖代码检查器在运行时之前捕获代码问题一样,提示工程师需要自动化质量检查来在执行前识别结构问题。在将提示投入生产之前,验证它们的清晰度、完整性和一致性可以显著提高可靠性并减少调试时间。

### 提示检查的必要性

提示容易出现几类结构问题:

* 模糊的指令:可以有多种解释的方向
* 冲突的约束:相互矛盾的要求
* 缺少格式指令:对输出结构的期望不清晰
* 遗忘的变量:未替换的模板占位符
* 示例不足:少样本模式没有足够的案例
* 角色不清晰:对模型的角色描述模糊

### LLM驱动的自检查

提示验证最强大的方法是使用LLM作为检查工具。这种元使用AI利用模型自身对语言和推理的理解来识别潜在问题:

```javascript
// 基于LLM的提示自检查
async function selfLintPrompt(prompt, model) {
  const metaPrompt = `
    你是一位提示工程专家,负责分析和改进提示。
    
    请检查以下提示的:
    1. 指令的清晰度
    2. 潜在的歧义
    3. 结构问题
    4. 缺失的约束或格式规范
    5. 要求的一致性
    
    请以以下JSON格式提供你的分析:
    {
      "overallQuality": number, // 1-10分
      "issues": [
        {
          "type": string, // 以下之一: "ambiguity", "structure", "contradiction", "missing", "other"
          "severity": string, // 以下之一: "error", "warning", "suggestion"
          "description": string,
          "recommendation": string
        }
      ],
      "improvedVersion": string // 修改后的提示
    }
    
    这是要分析的提示:
    
    """
    ${prompt}
    """
    
    只提供JSON输出,不要有任何额外的文本。
  `;
  
  const analysisResult = await model.complete(metaPrompt, { temperature: 0.1 });
  
  try {
    return JSON.parse(analysisResult);
  } catch (e) {
    return {
      error: "无法将LLM输出解析为JSON",
      rawOutput: analysisResult
    };
  }
}
```

如果我们给它这个提示来检查:

> 生成一个从API显示用户信息的React组件。让它看起来不错,如果可能的话添加一些好的功能。

通过这种方式,我们让LLM产生越来越好的提示,从而产生越来越好的代码。

## 提示就是代码

提示工程正在成为一个正式的开发者学科,就像编码的其他领域一样有模式、工具和方法论。你不会在没有测试的情况下写函数,那么为什么要在没有验证的情况下部署提示呢?你对代码进行版本控制,那么难道不应该对提示做同样的事情吗?这些相似之处随处可见。

这种方法之所以强大,是因为它利用了现有的软件开发实践。少样本示例基本上就是测试用例。思维链就像强迫模型展示其工作过程。骨架提示给你与传统代码中模板模式相同的控制。当你一致地应用这些技术时,让人们对AI感到紧张的不可预测性开始消失。你可以自信地发布由AI驱动的功能,知道它们会像系统中的任何其他组件一样按预期运行。

停止把你的提示当作一次性的字符串。像构建软件一样构建它们,像测试软件一样测试它们,像维护软件一样维护它们——然后看着你的AI交互变得像代码库的其他部分一样可靠。
